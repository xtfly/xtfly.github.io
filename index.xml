<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蘭陵N散記</title>
    <link>http://lanlingzi.cn/</link>
    <description>Recent content on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 04 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://lanlingzi.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>代码整洁与洁癖</title>
      <link>http://lanlingzi.cn/post/technical/2019/050_clean_code/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2019/050_clean_code/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;我司强执行力，很容易把事情做得极致，但有时过于极致反而带来不好的意外结果。我参与了公司C/Java等编程规范的评审，但让我受不了的是编程规范中条款事无巨细。连运算符或关键字之间几个空格都要写入规范，太多关于格式、命名等条款。这种在代码格式上的洁癖，可能是仁着见仁。但我司的特点是一旦形成规范，就会强行执行，先是考试，再是落入到项目中，像有几个空格这种拿来考试不是折磨人吗，能使用工具解决的为什么不去开发一个工具来提升效率，而不是死记硬背的规范。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>成就感</title>
      <link>http://lanlingzi.cn/post/thoughts/2019/0427_fulfillment/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2019/0427_fulfillment/</guid>
      <description>&lt;p&gt;前天公司HR找我聊天，聊到问我的成就感是什么。我想表达的观点是成就感是内心一直能处于心态平和，心里踏实，不为事情所扰。尤其是作为一名技术人员，当前的工作是希望是不被打扰，不要去呈现价值，不要去讲故事而去获取更多的资源；而是把自己手上的工作尽自己最大可能努力去做好，自己问心无愧，自己也收获成长。&lt;/p&gt;

&lt;p&gt;这似乎有点高大上，不食人间烟火；或者是一种上升到生活哲学的感悟。现实生活中，我们到处都有着功利心，成就感就是对功利的满足。人们更乐于朝着自己收益最大的方向努力，而不是原地享受安逸。个人很难超脱学古人淡泊名利，即使在相对单纯的技术体系，你也会发现人没有功利心的确是一种不容易的事情。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一指流沙，程序年华</title>
      <link>http://lanlingzi.cn/post/thoughts/2018/1226_hw_soft_king/</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2018/1226_hw_soft_king/</guid>
      <description>&lt;p&gt;时间就像指间握不住的流沙，静静从身边溜走。&lt;/p&gt;

&lt;p&gt;这些年来，我所从事的工作领域在变化，所使用的技术在变化，经历过一线比拼的激情，持续熬夜的艰辛，产品上线的喜悦，一直在公司从事基层研发工作。人生就像自己编写的程序，在程序化地运行着，但能在最好的年华，做自己最热爱的事，于我是一种幸福。&lt;/p&gt;

&lt;h2 id=&#34;有了电脑后的-放飞&#34;&gt;有了电脑后的“放飞”&lt;/h2&gt;

&lt;p&gt;上世纪90年代，爸爸单位用电脑记账，我觉得很是神奇，买不起电脑就买了个学习机，按照说明书，用GBASIC语言输出满屏各种形状的图形，心中被巨大的喜悦填满，开始了编程的启蒙。高考那年，又被《第一次亲密接触》中互联网的桥段吸引，毫不犹豫报了计算机专业，但遗憾被调剂到信息管理专业，这两个专业之间关系不大，我与编程失之交臂了。&lt;/p&gt;

&lt;p&gt;大一下学期买了电脑后，我开始“放飞”自己，各种操作系统只要出新的版本，我就会重装体验，此外就是打游戏，或者“泡”论坛，渐渐发现编程的乐趣，之后就在编码的路上停不下来了。参加过学校计算机编程比赛获三等奖，和室友一起搭建系里的网站，大学毕业去了一家互联网公司做程序员，直到2005年，我有幸加入华为，一晃已经十三年了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Scala中的符号</title>
      <link>http://lanlingzi.cn/post/notes/2018/0721_scala_symbol/</link>
      <pubDate>Sat, 21 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2018/0721_scala_symbol/</guid>
      <description>&lt;p&gt;Scala被有人戏称是 “太阳系最难的语言” ，那我们来看看他那些各种奇怪的符号使用吧，语言充满语法糖，真让人甜得受不了。一旦这些符号组合起来使用，那只能用 “惊为天书” 来形容啊。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;(map1 /: map2 ) { case (map, (k,v)) =&amp;gt; map + ( k -&amp;gt; (v + map.getOrElse(k, 0)) ) }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的看得懂吗，其实要实现的就是：合并两个Map集合对象（将两个对应KEY的值累加）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;说明：本文为学习笔记，下面内容多数来源于网上多篇文档的收集与汇总，在此感谢原作者们。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;泛型&#34;&gt;泛型&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;scala中泛型使用&lt;code&gt;[]&lt;/code&gt;指定泛型的类型参数，上下文界定是隐式参数的语法糖&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt; 表示上下文界定，如&lt;code&gt;A：B&lt;/code&gt; 表示 B 可以进行隐式转化的A类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T:A:B&lt;/code&gt; 表示即同时满足AT这种隐式值和BT这种隐式值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;与&#34;&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt; 与 &lt;code&gt;:&amp;gt;&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt; 表示只限定子类，如 &lt;code&gt;T &amp;lt;: A&lt;/code&gt; 表示T必须为A的子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;:&lt;/code&gt; 表示只限定子类，如 &lt;code&gt;T &amp;gt;: A&lt;/code&gt; 表示T必须为A的父类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt; 与 &lt;code&gt;:&amp;gt;&lt;/code&gt; 相当于java范型编程中的extends，super对泛型变量的限定。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T &amp;lt;: A with B&lt;/code&gt; 表示A和B为T上界&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T &amp;gt;: A with B&lt;/code&gt; 表示A和B为T下界&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T &amp;gt;: A &amp;lt;: B&lt;/code&gt; 表示同时拥有上界和下界，并且A为下界，B为上界，A为B的子类，顺序不能颠倒。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Cache设计</title>
      <link>http://lanlingzi.cn/post/technical/2018/0624_cache_design/</link>
      <pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2018/0624_cache_design/</guid>
      <description>&lt;p&gt;一提到Cache，就想到08年我为公司写的消息缓存系统的惨痛教训。当时Redis与Memcached远还没有流行，公司对使用开源项目也是慎重，于是我和另一个同事自己撸了一个系统，但做着做着就变成一个带有强业务逻辑的Cache了。后面又扩大他的使用场景，也导致了一些问题。这个系统的要满足如下场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;针对消息对象缓存，每个消息都非常小，要高效地使用内存&lt;/li&gt;
&lt;li&gt;存在定时消息，当定时到了，需要回到业务系统中去调度&lt;/li&gt;
&lt;li&gt;消息有优先级与时序性，要支持按不同的属性来索引（消息ID，发送人，收件人等）&lt;/li&gt;
&lt;li&gt;消息量非常大，缓存需要有淘汰机制，支持淘汰的消息本地文件存储（相当于多级缓存，本地文件存储要求高效索引）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面的场景来，它比纯Key/Value的缓存复杂，即要高效使用内存，同一个Value缓存，存在多个Key映射，而Value只能缓存一份，Value有优先级与时序性，索引时需排序处理，又有点消息队列的诉求。&lt;/p&gt;

&lt;p&gt;今天，我们大量在使用Redis来做缓存，Redis只作为Key/Value存储，上层复杂的缓存相关业务逻辑是在其外来叠加实现。但由于对于业务系统来说，永远都是具体情况具体分析，没有最好，只有最合适，所以也不得不要考虑通用问题：缓存穿透、缓存雪崩，缓存击穿。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>自定义扩展Spring Cache注解</title>
      <link>http://lanlingzi.cn/post/technical/2018/0623_customize_spring_cache/</link>
      <pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2018/0623_customize_spring_cache/</guid>
      <description>&lt;p&gt;昨天在公司发现采用@Aspect定义一个切面，对MyBatis的Mapper接口方法上标注自定义的注解，无法切入拦截。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Spring Cache提供了声明式的@Cacheable等注解，很方便地对Mapper接口方法来实现缓存。他们好用但简单，缓存的Key大多选择主键。但实际项目上有不少关系对象表（如下面的代码所示）；不能采用主键作为Key，因为大多数的查询场景是根据其关联的另一个字段查询。若以此字段作为Key，当存在批量插入，更新或删除时，都会影响缓存的数据。而Spring Cache的注解无法对参数为数组或List的生成Key。&lt;/p&gt;

&lt;p&gt;于是想到自定义Cache注解来解决批量插入，更新或删除来刷新相应的缓存。对注解的拦截@Aspect声明的切面是最为简单的方式。核心实现代码如下：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust支持既存类型的理解</title>
      <link>http://lanlingzi.cn/post/technical/2018/0602_existential_types/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2018/0602_existential_types/</guid>
      <description>&lt;p&gt;最近利用周末时间来学习Rust编程，发现新发布的1.26版本，带来了&lt;a href=&#34;https://github.com/rust-lang/rust/pull/49255&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;，一时对它的写法难以理解，今天又找点资料再温习一下。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;impl Trait is now stable allowing you to have abstract types in returns or in function parameters. e.g. fn foo() -&amp;gt; impl Iterator&lt;Item=u8&gt; or fn open(path: impl AsRef&lt;Path&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;既存类型&#34;&gt;既存类型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;impl Trait&lt;/code&gt;是对&lt;a href=&#34;https://en.wikipedia.org/wiki/Type_system#Existential_types&#34;&gt;&lt;code&gt;既存类型(Existential types)&lt;/code&gt;&lt;/a&gt;的支持，那什么是既存类型?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从Archlinux到Manjaro&#43;i3 WM</title>
      <link>http://lanlingzi.cn/post/notes/2018/0415_manjaro_i3/</link>
      <pubDate>Sun, 15 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2018/0415_manjaro_i3/</guid>
      <description>&lt;p&gt;这个周未又在家折腾我的Archlinux，把Archlinux换成了Manjaro，窗口管理采用i3-wm，先上图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/screenshot/manjaro/1.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://lanlingzi.cn/images/screenshot/manjaro/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>响应式编程</title>
      <link>http://lanlingzi.cn/post/technical/2017/1001_reactive_programming/</link>
      <pubDate>Sun, 01 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/1001_reactive_programming/</guid>
      <description>&lt;h2 id=&#34;rxjava&#34;&gt;RxJava&lt;/h2&gt;

&lt;p&gt;最早接触响应式编程，是分析Netflix的架构时，发现Netflix系统中大量使用了&lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava(Reactive Extension for Java)&lt;/a&gt;。由于Netflix中服务的高并发请求，需要一个高效的异步编程框架，于是他们参考了微软的&lt;a href=&#34;http://Rx.Net&#34;&gt;Rx.Net&lt;/a&gt;的实现原理，在JVM上实现了响应式编程(Reactive Programming)的一种方式。同类的库还有&lt;a href=&#34;http://projectreactor.io/&#34;&gt;Project Reactor&lt;/a&gt;, &lt;a href=&#34;https://akka.io/&#34;&gt;Akka&lt;/a&gt;和&lt;a href=&#34;https://github.com/google/agera&#34;&gt;Agera&lt;/a&gt;等等。&lt;/p&gt;

&lt;p&gt;传统编程模式下，我们通常是同步实现。同步是最能简单理解的，调用一个函数或方法，等待响应返回。但对于要求高并发的服务端的软件开发，同步实现带来的开销也是巨大的。像Java中，并没有语言层面实现异步，如果没有借助一些框架，1K的并发请求，可能使用1K的线程来处理；如果采用一些异步框架来实现异步，就会像早期的JavaScript，通常是CallBack，Future模式，代码逻辑变得离散而复杂，造成所谓的&lt;code&gt;Callback Hell&lt;/code&gt;。JavaScript在ES6引入Promise机制，在ES7引入async关键字，就是想语言原生层面来解决&lt;code&gt;Callback Hell&lt;/code&gt;。而Go语言则更进一步，在内置Runtime中，通过Goroutine调度实现IO调用等异步机制，让上层使用感不到异步调用的存在。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件的困境</title>
      <link>http://lanlingzi.cn/post/thoughts/2017/0925_soft_dilemma/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2017/0925_soft_dilemma/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/soft_rm_.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近我司的软件产品线面临其史上最大的因境，今天晚上坐班车时，与一位曾经共过事的同事，聊起现在的软件，感慨颇多。大家都认为我们镨过太多的机会点，现在面对互联网软件的直面冲击，以及运营商本身经营上的乏力，运营商这个领域的软件已经无力回天了。另外之前与其它的同事也聊过，我司本质是一家硬件公司，没有做软件的基因。凭着做硬件的套路，做了这么多年的软件产品，也实属于不容易了。做软件产品与做软件服务是完全不同的套路，软件产品是需要卖给不同的客户，交付形态存在多样化，定制不可避免。而卖服务给不同的客户，客户关注是的服务体验，并不太关心软件的本身，只要软件能搞定客户的问题就行，就不会像卖产品那样面临不同的交付形态问题。而目前我们最大的因境就是软件产品不具有可复制性，不能像硬件那样形成规模效应。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开源DNS Server</title>
      <link>http://lanlingzi.cn/post/technical/2017/0910_dns_opensource/</link>
      <pubDate>Sun, 10 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0910_dns_opensource/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/dns.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DNS是互联网的基础设施，开源的DNS也有不少，下面列出主要的几种供参考：&lt;/p&gt;

&lt;h2 id=&#34;bind9&#34;&gt;Bind9&lt;/h2&gt;

&lt;p&gt;ISC（Internet System Consortium）的Bind一直以来基本上都是DNS的工业标准，Bind应该是目前世界上使用最为广泛的DNS服务器了。Bind起源于1980年的Berkeley大学，比起我的年龄还大，Bind的名称也是源自&lt;code&gt;Berkeley Internet Name Domain&lt;/code&gt;。不过Bind也是一直漏洞不断，Bind9是ISC开发人员对Bind重写，目前常见的Linux发行版本中，会自带Bind9的安装包。&lt;/p&gt;

&lt;p&gt;Bind9可以作为权威与递归DNS。主要特性如下：&lt;/p&gt;

&lt;p&gt;作为权威DNS时：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[转]DNS扫盲系列</title>
      <link>http://lanlingzi.cn/post/technical/2017/0903_dns/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0903_dns/</guid>
      <description>&lt;p&gt;致谢：转自 &lt;a href=&#34;http://bbs.chinaunix.net/thread-1573358-1-1.html&#34;&gt;http://bbs.chinaunix.net/thread-1573358-1-1.html&lt;/a&gt;  ，由 &lt;a href=&#34;http://bbs.chinaunix.net/space-uid-71828.html&#34;&gt;llzqq&lt;/a&gt; 发表。&lt;/p&gt;

&lt;h2 id=&#34;有关公网dns&#34;&gt;有关公网DNS&lt;/h2&gt;

&lt;p&gt;公网DNS服务器是直接服务于广大上网用户的，负责域名（域名记录）到IP地址之间的翻译工作。公网DNS通常是各个网络运营商按照自己的网络分布规划DNS的分布，一般做法是按行政区域放置，如按省份放置。每个省份内也有细分在各地区放置的情况。&lt;/p&gt;

&lt;p&gt;近几年来细心的网友会发现上网时如果打错了URL地址（或干脆莫名其妙）会访问到114网站或百度等网站。今天我画了一个简单的图表简要说明一下原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/dns_1_arch.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>4A技术概览</title>
      <link>http://lanlingzi.cn/post/technical/2017/0730_4a/</link>
      <pubDate>Sun, 30 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0730_4a/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/4a_security.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是4a&#34;&gt;什么是4A&lt;/h2&gt;

&lt;p&gt;4A是指：账号Account、认证Authentication、授权Authorization、审计Audit，中文名称为统一安全管理平台解决方案。即将身份认证、授权、审计和账号(即不可否认性及数据完整性)定义为网络安全的四大组成部分，从而确立了身份认证在整个网络安全系统中的地位与作用。(来源百度百科)&lt;/p&gt;

&lt;h2 id=&#34;账号account&#34;&gt;账号Account&lt;/h2&gt;

&lt;p&gt;为用户提供统一集中的帐号管理，包括：用户身份信息的集中存储与统一管理。参考AWS等系统，涉及到概念包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主账号：一般指管理资源的唯一身份标识，他为资源付费。也是自然人在4A中的唯一身份标识，一个用户只会有一个主账号，唯一标识了他的身份。&lt;/li&gt;
&lt;li&gt;从账号：一般指资源访问的账号，如虚拟机的访问用户，数据库的访问用户等。&lt;/li&gt;
&lt;li&gt;用户：实现操作资源的人员，对应物理存在的人，它由账号分配。&lt;/li&gt;
&lt;li&gt;群组：一般对应企业的组织，把用户归属到一个群组里，用户可以自动获得这个群组所具有的权限。对于大型的企业，组织可能分为人员组织与业务组织。对于用户来说，群组也是为提供分级管理能力。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>云设计模式</title>
      <link>http://lanlingzi.cn/post/technical/2017/0715_cloud_design_pattern/</link>
      <pubDate>Sat, 15 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0715_cloud_design_pattern/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/azure.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在云环境下，如何构建出可靠，弹性，安全的应用？有哪些挑战？面对这些挑战如何解决，微软Azure总结一系列的设计模式。本文是翻译&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/&#34;&gt;Azure架构中心&lt;/a&gt;在线资料中的&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/&#34;&gt;云设计模式&lt;/a&gt;，仅个人的笔记，借翻译学习一下，英文好的可以直接阅读原文。&lt;/p&gt;

&lt;h2 id=&#34;挑战&#34;&gt;挑战&lt;/h2&gt;

&lt;h3 id=&#34;可用性&#34;&gt;可用性&lt;/h3&gt;

&lt;p&gt;可用性是指系统功能可用的时间占整体的比例，通常以正常运行时间比来衡量，它会受到系统错误、基础设施问题、恶意攻击和系统负载的影响。云应用典型为用户提供提供服务级协议（SLA），因此必须设计应用以最大限度地可用性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>运维模式</title>
      <link>http://lanlingzi.cn/post/technical/2017/0708_ops_pattern/</link>
      <pubDate>Sat, 08 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0708_ops_pattern/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/ops_pattern.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近一段时间由于工作内容重心变化，从PaaS系统的设计到运维系统的设计。运维系统的设计对我来说，还是一项全新的领域，需要学习的理念与技术很多。全司虽有大量的产品涉及到软件系统，但本质还是一个硬件盒子，运维的对象还是偏硬件。&lt;/p&gt;

&lt;p&gt;熟悉电信IT系统的人或许听说过：OSS(Operation Support System)，运营支撑系统，它是运营商IT系统中三大支柱系统之一。其它两大系统是：BSS(Bussiness Support System), MSS(Management Support System)。&lt;/p&gt;

&lt;p&gt;OSS是面向资源的后台支撑系统。资源主要包括网络，电信设备，计算系统等。系统的主要功能是包括专业网络管理，综合网络管理，资源管理，业务开通，服务保障等。但公司的产品线众多，产品形态也是千差万别，公司的OSS产品也一直在探索与发展。产品开发部门也是分分合合，一直是想打造一套统一的运营支撑平台。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>为什么我写不下去</title>
      <link>http://lanlingzi.cn/post/thoughts/2017/0626_how_to_write/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2017/0626_how_to_write/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/write_thinking.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;近一年来，写博客很少。总结起来有如下三点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有时间&lt;/li&gt;
&lt;li&gt;没有素材&lt;/li&gt;
&lt;li&gt;没有心情&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我很佩服那种每天都能写上千字博文或公众号的人，因为坚持写作需要很强的毅力。我没有能够坚持下来，其实最重要还是没有心情，动力不足。那作为一位内心深处又想写点东西的人，如何破？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Install MySQL on MacOS</title>
      <link>http://lanlingzi.cn/post/notes/2017/0603_mac_mysql/</link>
      <pubDate>Sat, 03 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2017/0603_mac_mysql/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/y17/mysql.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近在家想写的东西，在MacOS上需要使用到MySQL。在MacOS下，使用brew来安装软件是最便捷。关于brew是什么，可在brew官网查看：&lt;a href=&#34;https://brew.sh/index_zh-cn.html&#34;&gt;brew官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;➜  ~ brew info mysql
mysql: stable 5.7.18 (bottled)
Open source relational database management system
......
➜  ~ brew install mysql&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>PaaS的发展</title>
      <link>http://lanlingzi.cn/post/technical/2017/0304_paas/</link>
      <pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0304_paas/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/paas/paas1.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;云计算按提供服务层次，通常划分为三层：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IaaS ：基础构架即服务。这一层主要是对基础设施进行管理以给用户提供资源使用，如提供计算服务、安全备份、负载管理等。&lt;/li&gt;
&lt;li&gt;PaaS ：平台即服务。这一层主要是基于IaaS之上，简化应用的部署、维护等，提供一些通用平台软件能力，如数据挖掘、系统管理、编程模型等。&lt;/li&gt;
&lt;li&gt;SaaS ：软件即服务。这一层主要是面向终端客户，提供一站式的解决方案。如提供CRM、HRM、SCM等，是可以直接使用其服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个人一直从事PaaS的研发，而我们做的又是面向电信领域的PaaS。与外面的朋又交流发现，大家对PaaS的理解是不一样的，主要还是由于PaaS的本质是要解决的问题是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;简化开发，打通DevOps，实现业务应用的敏捷与弹性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同的业务领域，要面对是&lt;code&gt;不同的传统应用架构如何通过PaaS平台迁移到云上&lt;/code&gt;，这就会导致各自对PaaS的需求或多或少有着不同的差异，理解不一样也是正常的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Design for Failure</title>
      <link>http://lanlingzi.cn/post/technical/2017/0216_dff/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0216_dff/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/dff/dff.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;故有的思维会影响创新，在传统的软件设计考虑高可靠性，主要方法论是”防“，处处保护，让系统的每一处能长时间运行，不中断地提供服务。事实上电信级高可用性（HA）也只能宣称达到5个9，这意味着一年也就只有5分半钟的中断时间。但每增加一个9却实施成本非常地高，有些是建立在硬件可靠基础之上，并且不少是实验数据或理论上支持。传统的思维认识，在泥沙上建房子不可靠的。但软件架构设计，即完全不一样，在不可靠的基础设施上构建上可靠的系统，那才是真正NB的。&lt;/p&gt;

&lt;p&gt;依稀记得云计算刚出来时，大家都是持怀疑态度：性能下降的虚拟化技术、安全不可控的网络、变化复杂的资源管理，在其上如何构建可靠稳定的软件系统？事实上，Netflix完全基于AWS云基础设施，认为都有可能发生任何的故障（Failure），更何况资源也不掌握在自己手上。Netflix基于&lt;code&gt;Design for Failure&lt;/code&gt;理念却构建出用户无感知的高可用系统，支撑他的业务飞速发展。事实上，故障无所不在，尤其是在云计算环境中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;资源层次：电能失效，整个数据中心不可用；部分计算失效，网络不通，存储IO高等&lt;/li&gt;
&lt;li&gt;应用层次：资源泄露；软件Bug；系统处理能力不足等&lt;/li&gt;
&lt;li&gt;数据层次：数据丢失；数据不一致等&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>35还能做技术吗</title>
      <link>http://lanlingzi.cn/post/thoughts/2017/0208_35_change/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2017/0208_35_change/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/change/change.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近我司心声社区到处充斥着在40岁左右惯例的帖子，之前觉得这些觉得离自己很远。不经意发现自己今年也35岁了，惯例这一天迟早会来临，只是早晚而已，按目前现状，再为公司奋斗也不会有太多年了，你想奋斗关键公司不让你啊。最近也陆续听到之前曾经共事的同事，或由于身体原因，被沟通退休或离职；或由于绩效平平，合同到期不再续签；或由于种种原因，被进入战备预备队前途不明。公司主营业务已遇到瓶颈，整个行业暮色深沉，新的领域就开拓不足，公司高层也不断地发文要打粮食，熵减等等。总之：“山雨欲来风满楼”。&lt;/p&gt;

&lt;p&gt;35岁应该是一个年富力强的年龄，不应该发出“今年35，还能做技术吗？”这样的话题，其中透露出一丝不自信。话说三十而立，但目前这个年龄段，我是上有老，下有小，身上还背着几百万的房贷，说没有压力不是可能的。作一名软件工程师，在国内来说其职业生涯是相当短的。而我一直从事软件相关的工作，目前虽是做软件架构设计，但还是喜欢写写代码，一直没有找到自己明确的发展方向，一方面有我自身的性格原因，一方面能力的确有些偏科。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>再说说微服务</title>
      <link>http://lanlingzi.cn/post/technical/2017/0207_msa_think/</link>
      <pubDate>Tue, 07 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0207_msa_think/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/msa/timg.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;

&lt;p&gt;我司从15年开始学习互联网的微服务构架，到今16年的全云化战略，微服务已作为架构体系的重要工作。但微服务看似美好，在IT界应用非常的成熟与成功，但这个本质没有革命性的技术架构，在我司却非常地难以落地。主要原因：传统的CT应用太过厚重，面临着软件交付模式完全不一样，历史包袱改造面临短期看不到收益的成本投入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IT界：软件是自运维，借助于微服务构架，DevOps工程化，以及相对扁平的组织结构。软件向微服务转变相对阻力比较小，按康威定律，组织决定架构，微服务构架与扁平化、轻小的、精英化的组织是完全匹配的。在微服务构架实施上可以快速迭代演进，同时形成回路反馈，架构更符合良性的发展。同时像BAT等公司，业务上爆发式的增涨，也会加速微服务构架软变与满足。&lt;/li&gt;
&lt;li&gt;我司：软件非自运维，做的是产品卖给运营商，DevOps当前无法直接打通。微服务构架对交付与运维来说，没有直接带来价值，反而会带来更多的问题。运营商是不可能像IT界每日构建灰度升级的。当然运营商自己也在改变，但这个改变是基础设施平台化，上层业务应用会拉入IT厂商，反而像我司这类传统的设备供应商会被旁落。说起来，这是另一个更大沉重的话题，不就再展开了。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go性能优化小结</title>
      <link>http://lanlingzi.cn/post/technical/2017/0203_go_optimize/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0203_go_optimize/</guid>
      <description>&lt;h2 id=&#34;内存优化&#34;&gt;内存优化&lt;/h2&gt;

&lt;h3 id=&#34;小对象合并成结构体一次分配-减少内存分配次数&#34;&gt;小对象合并成结构体一次分配，减少内存分配次数&lt;/h3&gt;

&lt;p&gt;做过C/C++的同学可能知道，小对象在堆上频繁地申请释放，会造成内存碎片（有的叫空洞），导致分配大的对象时无法申请到连续的内存空间，一般建议是采用内存池。Go runtime底层也采用内存池，但每个span大小为4k，同时维护一个cache。cache有一个0到n的list数组，list数组的每个单元挂载的是一个链表，链表的每个节点就是一块可用的内存，同一链表中的所有节点内存块都是大小相等的；但是不同链表的内存大小是不等的，也就是说list数组的一个单元存储的是一类固定大小的内存块，不同单元里存储的内存块大小是不等的。这就说明cache缓存的是不同类大小的内存对象，当然想申请的内存大小最接近于哪类缓存内存块时，就分配哪类内存块。当cache不够再向spanalloc中分配。&lt;/p&gt;

&lt;p&gt;建议：小对象合并成结构体一次分配，示意如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;for k, v := range m {
    k, v := k, v // copy for capturing by the goroutine
    go func() {
        // using k &amp;amp; v
    }()
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替换为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;for k, v := range m {
    x := struct {k , v string} {k, v} // copy for capturing by the goroutine
    go func() {
        // using x.k &amp;amp; x.v
    }()
}&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>CloudNative初探</title>
      <link>http://lanlingzi.cn/post/technical/2017/0106_cloudnative/</link>
      <pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0106_cloudnative/</guid>
      <description>&lt;p&gt;随着日益普及的云计算，越来越多的传统应用迁移到云上。尤其是视频巨头NetFlix从2009年开始，放弃构建自己的数据中心，把所有应用迁移到AWS。NetFlix认为云环境下，everything will be failure。它基于微服务架构，以及Design for failure理论，构建出一系统非常成功的云应用（微服务），支持它的业务飞速发展。NetFlix认为他们比Amazon自己更懂得AWS。同时业界也提出了CloudNative概念，Netflix的应用也认为目前最为成功的CloudNative应用（参考&lt;a href=&#34;http://www.slideshare.net/adrianco/netflix-what-changed-gartner-catalyst&#34;&gt;Cloud Native at Netflix&lt;/a&gt;）。那什么是CloudNative？&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;目前对CloudNative并没有明确的定义。15年，Google联合其他20家公司宣布成立了开源组织Cloud Native Computing Foundation（CNCF）。想通过开源的Kubernetes，在云计算领域占据主层地位。当然Kubernetes目前是一个以应用为中心容器编排，调度集群管理系统。它想做的是CloudNative Application的基石。从CNCF组织来看，CloudNative Application应该包含微服务，容器，CI/CD特征。&lt;/p&gt;

&lt;p&gt;早在2010年，WSO2的联合他始人Paul Fremantle在业界最早提出&lt;a href=&#34;http://wso2.com/library/articles/2010/05/blog-post-cloud-native/&#34;&gt;CloudNative，认为有如下几个关键特征&lt;/a&gt;：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go依赖管理机制</title>
      <link>http://lanlingzi.cn/post/technical/2016/1120_go_deps_mgnt/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/1120_go_deps_mgnt/</guid>
      <description>&lt;p&gt;无论何种语言，依赖管理都是一个比较复杂的问题。而Go语言中的依赖管理机制目前还是让人比较失望的。在1.6版本之前，官方只有把依赖放在GOPATH中，并没有多版本管理机制；1.6版本（1.5版本是experimental feature）引入vendor机制，是包依赖管理对一次重要尝试。他在Go生态系统中依然是一个热门的争论话题，还没有想到完美的解决方案。&lt;/p&gt;

&lt;h2 id=&#34;看其它&#34;&gt;看其它&lt;/h2&gt;

&lt;p&gt;我们先来看看其它语言怎么解决，例举两种典型的管理方式：&lt;/p&gt;

&lt;h3 id=&#34;java&#34;&gt;Java&lt;/h3&gt;

&lt;p&gt;开发态，可以通过maven和gradle工具编辑依赖清单列表/脚本，指定依赖库的位置/版本等信息，这些可以帮助你在合适的时间将项目固化到一个可随时随地重复编译发布的状态。这些工具对我来说已经足够优雅有效。但maven中也有不同依赖库的内部依赖版本冲突等令人心烦的问题。尤其是在大型项目中的依赖传递问题，若团队成员对maven机制没有足够了解下，依赖scope的滥用，会让整个项目工程的依赖树变得特别的巨大而每次编译效率低下。运行态，目前Java也没有很好的依赖管理机制，虽有classloader可以做一定的隔离，但像OSGi那种严格的版本管理，会让使用者陷入多版本相互冲突的泥潭。&lt;/p&gt;

&lt;h3 id=&#34;node-js&#34;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;npm是Node.js的首选模块依赖管理工具。npm通过一个当前目录的 package.json 文件来描述模块的依赖，在这个文件里你可以定义你的应用名称( name )、应用描述( description )、关键字( keywords )、版本号( version )等。npm会下载当前项目依赖模块到你项目中的一个叫做node_modules的文件夹内。与maven/gradle不同的是，maven最终会分析依赖树，把相同的软件默认扁平化取最高版本。而npm支持nested dependency tree。nested dependency tree是每个模块依赖自己目录下node_modules中的模块，这样能避免了依赖冲突, 但耗费了更多的空间和时间。由于Javascript是源码发布，所以开发态与运行态的依赖都是基于npm，优先从自己的node_modules搜索依赖的模块。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>思维图形化</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/1118_arch_drawing/</link>
      <pubDate>Fri, 18 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/1118_arch_drawing/</guid>
      <description>&lt;p&gt;曾经，我幼稚地认为：只有写好代码才能对产品最“大”的贡献。什么需求分析文档，架构设计文档，没有最终的代码落地，那就是一张张的空纸。那些职位高高在上的架构师们，就也是写写胶片，画画图，他们又不懂技术细节，天天开会讨论来，讨论去都是在空谈一切。没有我们这些屌丝写的代码，你让他们去实现，估计几年也搞不出来。我写代码的能力比他们顶上N个人；再看看人家老外，60/70岁了还在码代码。为什么我国到了30岁了，都不去写代码了，都去搞所谓的架构设计了。是他们写代码写不好才去干架构师活吗？&lt;/p&gt;

&lt;p&gt;经过这么多年在产品中挖坑、填坑，发现我们的产品是越来越复杂，但使用上也是越来越复杂，问题也是越来越难理清。我们的问题到底是出在什么地方：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Archlinux on WSL</title>
      <link>http://lanlingzi.cn/post/notes/2016/1030_archlinux_wsl/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/1030_archlinux_wsl/</guid>
      <description>&lt;p&gt;最近国庆某东活动，搞了一台HP的笔记本，系统是Win10。经过不断地折腾，在Win10上启用了Windows Subsystem for Linux（简称WSL），并在WSL上安装了Archlinux。加入Insider Preview会员计划，可以最快地获取Win10的最新内部版本，以便及时获取WSL的功能更新。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>团队管理</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/1027_team_mgnt/</link>
      <pubDate>Thu, 27 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/1027_team_mgnt/</guid>
      <description>&lt;p&gt;最近由于Go语言项目，又带一个小团队。以前作为团队的Leader，总是遇到各种问题，尤其是如何管理好人很困惑。HW的组织相对是比较宽松的，内部号称是矩阵式，感觉一个团队的凝聚力个人还是来源于Leader的个人技术感召力。好吧，这个只是凭感觉的管理，这是远远不够的。&lt;/p&gt;

&lt;p&gt;作为一个技术团队的小Leader，整体来讲，它面临”业务“，”人“，”事“这三个方面的工作展开。这些是来源公司内牛人们的一些总结，我把他们纪录下来，是为了我更好地开展工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件变革下设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</guid>
      <description>&lt;p&gt;传统大型软件系统 ，多以功能需求驱动设计与开发。在体系结构上是一个单体应用，变更修改往往是牵一而发动全身；在系统生态上是一个封闭系统，系统集成是大量定制开发。单体封闭的系统在交付中面临着越来越多的挑战，提升系统的竞争力首先是在软件架构上先行。软件系统发展也需像硬件一样不断地更新换代，软件架构设计需要输入新的思维。只有在思想上彻底地变革，才能摆脱原有的束缚与局限性。&lt;/p&gt;

&lt;h2 id=&#34;体验为王&#34;&gt;体验为王&lt;/h2&gt;

&lt;p&gt;软件原本是一种信息技术发展不断地服务于各行各业，软件在实现上又是偏向技术性。如何让普通用户能够较好地使用软件，而不需要这方面的专业背景，需要思考软件减少数字与体验之间鸿沟。互联网思维一直讲求如何让用户感知到你对他的价值，而且把这个价值争取做到极致，超出用户的预期，这个就叫体验。只有用户产生体验之后，才能形成口碑。简而言之，体验的思想，就是从用户的感受出发，把它做到极致。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go map key类型分析</title>
      <link>http://lanlingzi.cn/post/technical/2016/0904_go_map/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0904_go_map/</guid>
      <description>&lt;p&gt;团队成员中大多是原来做Java，深受Java的影响，对于使用map问得最多的：map的key如何计算它的HashCode。下面试图通过讲解一些类型知识来解答。&lt;/p&gt;

&lt;h2 id=&#34;map的key类型&#34;&gt;map的key类型&lt;/h2&gt;

&lt;p&gt;map中的key可以是任何的类型，只要它的值能比较是否相等，Go的&lt;a href=&#34;http://golang.org/ref/spec#Comparison_operators&#34;&gt;语言规范&lt;/a&gt;已精确定义，Key的类型可以是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布尔值&lt;/li&gt;
&lt;li&gt;数字&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;指针&lt;/li&gt;
&lt;li&gt;通道&lt;/li&gt;
&lt;li&gt;接口类型&lt;/li&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;只包含上述类型的数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但不能是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slice&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go VIM开发环境</title>
      <link>http://lanlingzi.cn/post/technical/2016/0903_vim/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0903_vim/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;个人最近一直使用VSCode+Go插件来开发Go代码，虽然也觉得VSCode是目前最好用的Go的开发工具，但还是对VIM有点不可割舍，对我来说原因有三：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VIM可以在控制台使用，适合远程登陆到Linux进行代码调试修改&lt;/li&gt;
&lt;li&gt;配合Tmux使用，开启多个Pane各司其职，不同Pane之间快速切换&lt;/li&gt;
&lt;li&gt;有Tagbar，团队内代码串讲，能先看出每个文件的大纲，代码跳转也非常方便&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;截图&#34;&gt;截图&lt;/h2&gt;

&lt;p&gt;第一张是自己截的，后两张是使用各插件官方的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/vim/vim-snapshot.png&#34; alt=&#34;snapshot&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>入园家长沟通会</title>
      <link>http://lanlingzi.cn/post/stories/2016/0829_kid_garden/</link>
      <pubDate>Mon, 29 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2016/0829_kid_garden/</guid>
      <description>&lt;p&gt;时间真是过得太快，转眼儿子要上幼儿园了。昨天是第一次参加儿子的入园家长沟通会。&lt;/p&gt;

&lt;h2 id=&#34;上幼儿园的意义&#34;&gt;上幼儿园的意义&lt;/h2&gt;

&lt;p&gt;上幼儿园是小孩步入社会第一步，是融入世界的起点。脱离原生家庭才能独立成长，幼儿园有孩子同龄的伙伴，可以让孩子收获不同的体验；幼儿园也有专业的老师，可以让孩子快乐自由的探索自己，认识朋友，体验世界。&lt;/p&gt;

&lt;p&gt;我平时的工作都比较忙，基本都是早七晚九，白天小孩要么是跟他奶奶，要么是跟他外婆。还好他妈妈是小学老师，晚上能投入一些时间与他相处。大家居住环境比较封闭，邻里来往不多, 小孩基本都是呆在家里的时间居多。他对家的依赖比较多。虽他平时也会经常去他妈妈工作的小学玩，但还是在大家的完全监控下。养孩子的最终目的是为了看着他们独立，幼儿园是教孩子独立的第一步，也是教家长放手的第一步。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hexo NexT主题移植</title>
      <link>http://lanlingzi.cn/post/technical/2016/0828_hugo_next_theme/</link>
      <pubDate>Sun, 28 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0828_hugo_next_theme/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;我应该是一个喜欢折腾的技术党。从采用Hugo建静态blog以来，算上今天移植的这个，一共使用了三个主题：&lt;/p&gt;

&lt;p&gt;第一个是修改自&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;Hueman&lt;/a&gt;，它是一个Wordpress主题。第二个是修改自&lt;a href=&#34;http://coderzh.github.io/hugo-pacman-theme/&#34;&gt;pacman&lt;/a&gt;，它是一个Hexo的主题。&lt;/p&gt;

&lt;p&gt;这二个主题都是&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;coderzh&lt;/a&gt;最早移植的，我只是在其上修改些布局，增加点功能，换个图片什么。这个过程让我弄清楚了Hugo中模板制作方法。&lt;/p&gt;

&lt;p&gt;第三个则是从零开始，移植Github上人气最高的Hexo主题：&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next/&#34;&gt;NexT&lt;/a&gt;。正如你现在看到的，NexT是一款简洁又富有动感的主题，当前天我第一眼看到它时，就喜欢上它的风格。于是乎趁着周日，就开始NexT主题移植之旅。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go测试</title>
      <link>http://lanlingzi.cn/post/technical/2016/0824_go_testing/</link>
      <pubDate>Wed, 24 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0824_go_testing/</guid>
      <description>&lt;p&gt;Go语言内置了测试框架，编写单元测试非常方便。&lt;/p&gt;

&lt;h2 id=&#34;命名约定&#34;&gt;命名约定&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试代码位于以&lt;code&gt;_test.go&lt;/code&gt;结尾的源文件中，一般与源码在同一个package中。&lt;/p&gt;

&lt;p&gt;位于同一个package中的主要原因是：测试可以访问package中不可导出的变量，方法等元素。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试源码可以修改package名，带上&lt;code&gt;_test&lt;/code&gt;结尾&lt;/p&gt;

&lt;p&gt;修改的package名称，不需要再单独新建立目录，也与源码在一个目录下。参考标准库的&lt;code&gt;bytes&lt;/code&gt;中的测试代码，方便使用被测试的元素，可以采用&lt;code&gt;.&lt;/code&gt;来import测试的package：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes_test&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
    . &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bytes&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;io&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
)&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Goroutine Local Storage</title>
      <link>http://lanlingzi.cn/post/technical/2016/0813_go_gls/</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0813_go_gls/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近在设计调用链与日志跟踪的API，发现相比于Java与C++，Go语言中没有原生的线程（协程）上下文，也不支持TLS（Thread Local Storage），更没有暴露API获取Goroutine的Id（后面简称&lt;code&gt;GoId&lt;/code&gt;）。这导致无法像Java一样，把一些信息放在TLS上，用于来简化上层应用的API使用：不需要在调用栈的函数中通过传递参数来传递调用链与日志跟踪的一些上下文信息。&lt;/p&gt;

&lt;p&gt;在Java与C++中，TLS是一种机制，指存储在线程环境内的一个结构，用来存放该线程内独享的数据。进程内的线程不能访问不属于自己的TLS，这就保证了TLS内的数据在线程内是全局共享的，而对于线程外却是不可见的。&lt;/p&gt;

&lt;p&gt;在Java中，JDK库提供&lt;code&gt;Thread.CurrentThread()&lt;/code&gt;来获取当前线程对象，提供&lt;code&gt;ThreadLocal&lt;/code&gt;来存储与获取线程局部变量。由于Java能通过&lt;code&gt;Thread.CurrentThread()&lt;/code&gt;获取当前线程，其实现的思路就很简单了，在ThreadLocal类中有一个Map，用于存储每一个线程的变量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解Go Interface</title>
      <link>http://lanlingzi.cn/post/technical/2016/0803_go_interface/</link>
      <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0803_go_interface/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Go语言中的&lt;a href=&#34;http://golang.org/doc/effective_go.html#interfaces&#34;&gt;接口&lt;/a&gt;很特别，而且提供了难以置信的一系列灵活性和抽象性。接口是一个自定义类型，它是一组&lt;a href=&#34;http://golang.org/ref/spec#Method_sets&#34;&gt;方法的集合&lt;/a&gt;，要有方法为&lt;a href=&#34;http://golang.org/ref/spec#Interface_types&#34;&gt;接口类型&lt;/a&gt;就被认为是该接口。从定义上来看，接口有两个特点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口本质是一种自定义类型，因此不要将Go语言中的接口简单理解为C++/Java中的接口，后者仅用于声明方法签名。&lt;/li&gt;
&lt;li&gt;接口是一种特殊的自定义类型，其中没有数据成员，只有方法（也可以为空）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接口是完全抽象的，因此不能将其实例化。然而，可以创建一个其类型为接口的变量，它可以被赋值为任何满足该接口类型的实际类型的值。接口的重要特性是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只要某个类型实现了接口所有的方法，那么我们就说该类型实现了此接口。该类型的值可以赋给该接口的值。&lt;/li&gt;
&lt;li&gt;作为1的推论，任何类型的值都可以赋值给空接口interface{}。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接口的特性是Go语言支持鸭子类型的基础，即“如果它走起来像鸭子，叫起来像鸭子（实现了接口要的方法），它就是一只鸭子（可以被赋值给接口的值）”。凭借接口机制和鸭子类型，Go语言提供了一种有利于类、继承、模板之外的更加灵活强大的选择。只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方。这种做法的学名叫做&amp;rdquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Structural_type_system&#34;&gt;Structural Typing&lt;/a&gt;&amp;ldquo;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解Go Context机制</title>
      <link>http://lanlingzi.cn/post/technical/2016/0802_go_context/</link>
      <pubDate>Tue, 02 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0802_go_context/</guid>
      <description>&lt;h2 id=&#34;什么是context&#34;&gt;什么是Context&lt;/h2&gt;

&lt;p&gt;最近在公司分析gRPC源码，proto文件生成的代码，接口函数第一个参数统一是&lt;code&gt;ctx context.Context&lt;/code&gt;接口，公司不少同事都不了解这样设计的出发点是什么，其实我也不了解其背后的原理。今天趁着&lt;code&gt;妮妲&lt;/code&gt;台风妹子正面登陆深圳，全市停工、停课、停业，在家休息找了一些资料研究把玩一把。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;通常被译作&lt;code&gt;上下文&lt;/code&gt;，它是一个比较抽象的概念。在公司技术讨论时也经常会提到&lt;code&gt;上下文&lt;/code&gt;。一般理解为程序单元的一个运行状态、现场、快照，而翻译中&lt;code&gt;上下&lt;/code&gt;又很好地诠释了其本质，上下上下则是存在上下层的传递，&lt;code&gt;上&lt;/code&gt;会把内容传递给&lt;code&gt;下&lt;/code&gt;。在Go语言中，程序单元也就指的是Goroutine。&lt;/p&gt;

&lt;p&gt;每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个&lt;code&gt;Context&lt;/code&gt;变量中，传递给要执行的Goroutine中。上下文则几乎已经成为传递与请求同生存周期变量的标准方法。在网络编程下，当接收到一个网络请求Request，处理Request时，我们可能需要开启不同的Goroutine来获取数据与逻辑处理，即一个请求Request，会在多个Goroutine中处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>为什么是Go</title>
      <link>http://lanlingzi.cn/post/technical/2016/0723_why_go/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0723_why_go/</guid>
      <description>&lt;p&gt;HW的执行力就是强，推广Go也是雷力风行，几乎目前是全员皆Go。作为一名其中的参与者，也知目前Go若大规模应用还是有很多的不成熟，风险也非常大。那为什么我司还是选择Go？也来谈谈我个人对为什么选择Go的认识，仅是个人拙见，不代表我司官方的观点。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Go语言主创人员之是C语言与Linux的发明人，所以Go的语法在C的基础之上取众家之精华：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主要继承了C(func, struct，指针)&lt;/li&gt;
&lt;li&gt;包管理吸取自Java（package, import）&lt;/li&gt;
&lt;li&gt;多态吸取自Python与Ruby(duck type)&lt;/li&gt;
&lt;li&gt;并发吸取自&lt;a href=&#34;http://doc.cat-v.org/inferno/4th_edition/limbo_language/&#34;&gt;Limbo&lt;/a&gt;(&lt;a href=&#34;https://en.wikipedia.org/wiki/Communicating_sequential_processes&#34;&gt;CSP&lt;/a&gt;模型)。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go语言不足</title>
      <link>http://lanlingzi.cn/post/technical/2016/0718_go_insufficient/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0718_go_insufficient/</guid>
      <description>&lt;p&gt;最近公司是在疯狂地推广Go语言，我也是推广小组成员。Go语言的确很多的优点，这里并不想表扬Go语言，而是说说它的不足。&lt;/p&gt;

&lt;h2 id=&#34;生态不成熟&#34;&gt;生态不成熟&lt;/h2&gt;

&lt;p&gt;一个语言的流行，都有其背后的推动者。Go语言是由Google公司创建与推动。最近我司的高层也亲自拜访了Go语言的主创人员。Google称目前已有100+的App从Java转向Go。Google内部主要有三大语言（C++、Java、Python），之前对Go语言的公司内部的政治意义大于它的实际使用。近两年来，语言的战略地位凸显，不断地在推动Go语言的应用。&lt;/p&gt;

&lt;p&gt;目前主要使用Go语言的公司是一些创业公司或互联网公司。而这些公司采用Go语言非技术的因素主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公司软件资产积累少，不存在切换其它语言成本，使用Go语言可以轻装上阵；&lt;/li&gt;
&lt;li&gt;互联网公司的技术人员流动大，Go语言面向开发简化，招人容易，上手快；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go语言在线书籍收集</title>
      <link>http://lanlingzi.cn/post/technical/2016/0717_go_book/</link>
      <pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0717_go_book/</guid>
      <description>&lt;h2 id=&#34;effective-go&#34;&gt;Effective Go&lt;/h2&gt;

&lt;p&gt;在线阅读：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hellogcc.org/effective_go.html&#34;&gt;http://www.hellogcc.org/effective_go.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go语言圣经&#34;&gt;Go语言圣经&lt;/h2&gt;

&lt;p&gt;Go语言圣经，《The Go Programming Language》 中文版本
&lt;img src=&#34;http://gopl-zh.b0.upaiyun.com/cover_middle.jpg&#34; alt=&#34;Go语言圣经&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目主页：&lt;a href=&#34;http://github.com/golang-china/gopl-zh&#34;&gt;http://github.com/golang-china/gopl-zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;项目主页：&lt;a href=&#34;http://bitbucket.org/golang-china/gopl-zh&#34;&gt;http://bitbucket.org/golang-china/gopl-zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原版官网：&lt;a href=&#34;http://gopl.io&#34;&gt;http://gopl.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Pandoc&#43;Mardown生成Web Slide</title>
      <link>http://lanlingzi.cn/post/notes/2016/0716_pandoc_md_ppt/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0716_pandoc_md_ppt/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;在我司PPT被称为胶片。一层层的汇报都是胶片承载，胶片也是做得非常漂亮。像我所在领域，架构师主要产出也是胶片，俨然无胶片就无架构。一方面个人非常羡慕胶片写得好（内容与外观）的人，另一方面觉得像使用MS的PowerPoint几乎要把一半的精力放在外观而不是内容上。甚至感觉到为了一个格式、一个颜色，调整都需要老半天时间。大家的胶片都做得漂亮，而你不可能也就只草草准备，尤其是给领导的胶片，人在江湖，身不由已。但做一名技术人员，内心还是比较抵触形式大于内容的胶片。昨天，一名同事给我展示了一个由Markdown生成Slide，给人感觉是耳目一新。&lt;/p&gt;

&lt;p&gt;Markdown是一种内容与形式的分享的轻量级标记语言，受到越来越多的人喜欢，只要只简单的文本编辑器，都能书写文本内容。那有什么工具能快速方便地生成Slide呢。Markdown本身是为了方便输出到HTML格式。而HTML+CSS+JS是一个开放的，可扩展的技术。自然Markdown也可以通过工具生成像PPT一样可以上下翻页的HTML Slide，同样借助CSS与JS的结合，Slide一样可以做得像PPT一样格式漂亮，动作酷炫。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Goroutine陷阱</title>
      <link>http://lanlingzi.cn/post/technical/2016/0703_goroutine/</link>
      <pubDate>Sun, 03 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0703_goroutine/</guid>
      <description>&lt;p&gt;Go在语言层面通过Goroutine与channel来支持并发编程，使并发编程看似变得异常简单，但通过最近一段时间的编码，越来越觉得简单的东西，很容易会被滥用。Java的标准库也让多线程编程变得简单，但想当初在公司定位Java的问题，发现很多的同学由于没有深入了解Java Thread的机制，Thread直接New从不管理复用，那Goroutine肯定也要面临这类的问题。&lt;/p&gt;

&lt;h2 id=&#34;goroutine泄漏问题&#34;&gt;Goroutine泄漏问题&lt;/h2&gt;

&lt;p&gt;Rob Pike在2012年的Google I/O大会上所做的“Go Concurrency Patterns”的演讲上，说道过几种基础的并发模式。从一组目标中获取第一个结果就是其中之一。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>第八届中国云计算大会简纪</title>
      <link>http://lanlingzi.cn/post/technical/2016/0519_cie_cloud/</link>
      <pubDate>Wed, 18 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0519_cie_cloud/</guid>
      <description>&lt;p&gt;第一次参加由电子协会举办的云计算大会，这届是在北京国家会议中心举行，据说这一届参加的人数有1.4W人。主题为“技术融合 应用创新”。云计算走到今天，已不在是什么新概念，在中国已大规格地使用起来。作为一名技术从业者，有幸参加，虽可能得不到干货，但可听一听，看一看，启发思路。&lt;/p&gt;

&lt;h2 id=&#34;云计算是产业变革的推进器&#34;&gt;云计算是产业变革的推进器&lt;/h2&gt;

&lt;p&gt;第一场是来自工业和信息化部副部长怀（进鹏）部长致辞，领导果然是领导，带病撑着拐杖登台。整个过程是滔滔不绝地精彩分享，作一名学术官员，能脱稿是我发挥，说明他这个领域的真正专家。核心观点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;云计算是解决方案，助推产业变革。给我们日常生活变化，也给我们产业带来新结构调整&lt;/li&gt;
&lt;li&gt;云计算与大数据互为孪生兄弟，助推企业、行业和信息化解决方案起到了特别的支撑作用&lt;/li&gt;
&lt;li&gt;云计算提供低成本便捷的IT资源，提供数字均衡发展，降低数字鸿沟，大幅度降低创业门槛&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Golang Web开发</title>
      <link>http://lanlingzi.cn/post/technical/2016/0515_go_web/</link>
      <pubDate>Sun, 15 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0515_go_web/</guid>
      <description>&lt;h2 id=&#34;标准库-net-http&#34;&gt;标准库[net/http]&lt;/h2&gt;

&lt;p&gt;采用Golang来开发Web应用或Rest接口的应用还是比较容易的。golang标准库就提供对Http协议的封装，主要涉及到&lt;code&gt;net/http&lt;/code&gt;包，它包括了HTTP相关的各种函数、类型、变量等标识符。标准库的&lt;code&gt;net/http&lt;/code&gt;是支持HTTP1.1协议，而目前Go1.6也支持HTTP2.0，包放在&lt;code&gt;golang.org/x/net/http2&lt;/code&gt;,后续可能会移到标准库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;库中主要涉及到如下几个类型与接口：&lt;/p&gt;

&lt;h3 id=&#34;request结构体&#34;&gt;Request结构体&lt;/h3&gt;

&lt;p&gt;封装了HTTP的请求消息，其结构如下，可以很方便的地取出Method，Header与Body。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Oracle Cloud Day见闻简纪</title>
      <link>http://lanlingzi.cn/post/technical/2016/0414_oracle_cloud_day/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0414_oracle_cloud_day/</guid>
      <description>&lt;p&gt;今天有幸参加Oracle举办的cloud day。Oracle从开始对云计算不敏感，到后来的大力投入，并购与产品整合，目前Oracle在云计算领域已涵盖IaaS，PaaS，SaaS。Oracle正借助于云计算，把帮助企业把传统的应用产品搬迁到云计算上。Oracle应用产品发发展战略三个核心阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无极限的应用产品支持：对所有目前使用Oracle OP部署方式的应用产品客户提供持续支持。&lt;/li&gt;
&lt;li&gt;下一代“云”应用产品的开发以及战略并购：基于统一标准的PaaS平台，并购整合并开发下一代的，最优的基于云的产品。&lt;/li&gt;
&lt;li&gt;切实可行的”云”之路：为客户提供各种服务和商务方案使客户以最小的投资风险采用Oracle云服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上也可以看出Oracle在云计算野心，它虽相对起步晚，但它由于在传统IT领域的优势，通过整合基础设施，平台与中间件，以及社交资源，是在云计算领域内少数几个能针对企业各种业务提供一套完整的解决方案，涵盖如下领域：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>制作Archlinux Docker基础Image</title>
      <link>http://lanlingzi.cn/post/notes/2016/0410_archlinux_docker_images/</link>
      <pubDate>Sun, 10 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0410_archlinux_docker_images/</guid>
      <description>&lt;p&gt;想在Mac本上使用Docker来运行Archlinux，家里安装的是长城宽带，无奈从docker hub下载Archlinux基础Image网速无法忍受。在国内的alauda.cn镜像中心搜索到有Archlinux基础Image，可能由于在Docker使用Archlinux国内人比较少，估计alauda.cn的CDN也没有缓存Archlinux基础Image，下载同样也是龟速，下载多次超时就放弃了。&lt;/p&gt;

&lt;p&gt;正好个人还有一台老的笔记本安装了Archlinux，那何不自己做一个基础Image。说真的，还没有从零开始做过基础Image。在Docker hub搜索时发现有一个已有的脚本&lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/mkimage-arch.sh&#34;&gt;mkimage-arch.sh&lt;/a&gt;，于是把它做了些改造，制作过程记录一下：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件架构一些感想</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/0319_arch_diathesis/</link>
      <pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/0319_arch_diathesis/</guid>
      <description>&lt;h2 id=&#34;软件架构&#34;&gt;软件架构&lt;/h2&gt;

&lt;p&gt;软件系统架构不只是软件本身架构，它是一个全系统、全网络的架构，从层次上由低到高分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序架构&lt;/li&gt;
&lt;li&gt;系统架构&lt;/li&gt;
&lt;li&gt;产品架构&lt;/li&gt;
&lt;li&gt;生态、商业模式的架构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何一个架构师，都是需要重点解决某方面的尖锐问题，同时避免在不合适的场景下，一种技术、一类框架或一种架构模式被滥用。架构就需要对整体框定好范围与约束。&lt;/p&gt;

&lt;p&gt;架构设计不可能面面俱到，要解决或是发挥关键路径上的资源合理有效的最大价值。一个好的架构，不会随着时间或业务的变换，而需要进行大的破坏性的变化。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Grub引导Win10</title>
      <link>http://lanlingzi.cn/post/notes/2016/0313_grub_win10/</link>
      <pubDate>Sun, 13 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0313_grub_win10/</guid>
      <description>&lt;p&gt;个人有两台笔记本电脑，一台Sony安装Win10，平时给岳父上上网，自己使用比较少；另一台是MBA，自己在捣腾点代码，写点东西。今天心血来潮，想体验一个KDE的plasma 5，于是又来折腾Sony安装双系统。由于在使用MBA之前，也在Sony上安装过Archlinux，不过后来安装Win10，又把Archlinux删除了。这次的双系统，Linux还是选择Archlinux。&lt;/p&gt;

&lt;p&gt;安装Archlinux按照Wiki一路下来很顺利，最后安装plasma，使用了一下，感觉也不够如此，可能是使用Mac OSX时间长了的原因。后面发现想回到Win10，发现Grub默认没有生成Win10的引导菜单。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</link>
      <pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</guid>
      <description>&lt;p&gt;软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。但为了能较好的发展，在软件设计时需要考虑一些原则。&lt;/p&gt;

&lt;h3 id=&#34;清晰原则-使用简洁接口-简单部件组合&#34;&gt;清晰原则：使用简洁接口，简单部件组合&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编程的本质就是要控制复杂度，后期维护会占用大部分的时间。&lt;/li&gt;
&lt;li&gt;降低整体复杂度，用清晰的接口把若干简单模块组合成一个复杂的系统。&lt;/li&gt;
&lt;li&gt;对外隐藏细节，“不要与陌生人说话”。&lt;/li&gt;
&lt;li&gt;多数问题局限天一个局部，不要影响到全局。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：本质是分而治之，复杂问题简单化，抽象框架，有序组全。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用tmux</title>
      <link>http://lanlingzi.cn/post/notes/2016/0221_mac_tmux/</link>
      <pubDate>Sun, 21 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0221_mac_tmux/</guid>
      <description>&lt;h2 id=&#34;什么是tmux&#34;&gt;什么是tmux&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tmux.github.io/&#34;&gt;tmux&lt;/a&gt;是一个支持多会话独立运行的优秀的终端复用软件。它类似&lt;a href=&#34;http://www.gnu.org/software/screen/&#34;&gt;GNU Screen&lt;/a&gt;，自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。&lt;/p&gt;

&lt;h2 id=&#34;tmux的使用场景&#34;&gt;tmux的使用场景&lt;/h2&gt;

&lt;p&gt;Mac自带的Iterm2很好用啊。既支持多标签，也支持窗体内部Panel的分割，为什么还要用tmux？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;与VIM配合使用，打造出更高效、更优雅的终端工具。尤其是在当前大屏幕显示器下，多标签和分割窗体，无缝跳转。既可使用vim来写代码，也可使用tmux来查询代码编译与支行结果。&lt;/li&gt;
&lt;li&gt;提供了一个窗体组随时存储和恢复的功能。调试程序，开了一堆窗口。出去吃了个饭，发现SSH超时了，如果使用tmux就attach就能找回原来打开的那些窗口。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>软件架构设计</title>
      <link>http://lanlingzi.cn/post/notes/2016/0215_about_soft_arch/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0215_about_soft_arch/</guid>
      <description>&lt;h2 id=&#34;什么是软件架构设计&#34;&gt;什么是软件架构设计&lt;/h2&gt;

&lt;p&gt;依稀记得公司的软件架构培训材料中说到软件架构=组件+交互。最近读温昱的&lt;a href=&#34;http://baike.baidu.com/link?url=FwG7S8RSOkY8BzeZ1MBRSppAkJsTZZZTHRlj8wjvq7r4BPowUlimOuVUyZusyrUvaYXurh8hqxF3O0FTxA-8c_&#34;&gt;《软件架构设计》&lt;/a&gt;才知道这只是其中一大阵营的观点。而软件架构在定义上分为&lt;code&gt;“组成派”&lt;/code&gt;和&lt;code&gt;“决策派”&lt;/code&gt;两大阵营。“组成派”认为软件架构是将系统描述成计算组件及组件之间的交互；而“决策派”认为软件架构包含了一系列的决策。事实上，从我司实际操作来看，两种观点并不是互斥的，而是相辅相成。两种观点只是站在不同的角度来看待软件架构。架构师在分割组件模块时，选择备选方案时，也是会不得不去作出各种决策，架构没有最完美的，只有在特定场景需求下最合适的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件开发知行合一</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/0131_unity_knowledge_action/</link>
      <pubDate>Sun, 31 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/0131_unity_knowledge_action/</guid>
      <description>&lt;p&gt;最近在走读团队的代码，有时实在是看不下去。不是因为他们的代码编写有很多Bugs，而是没有设计实现太复杂了。当面对众多的需求需要快速实现，没有几个人会去思考代码怎么写结构才更合理，而是在不断去搬砖垒需求。当我去咨询他们为什么要这样实现时，每个人能只能说出一，不知其二。即使自己写的代码，也不知道当初为什么这么实现。&lt;/p&gt;

&lt;p&gt;同时，我们团队中不乏有各种兴趣小组。例如学习新的技术框架，交流设计模型，讨论重构技巧、性能优化经验。而实际在操作层面上，代码却正如前面所讲，有时真的不堪入目。由于这近在看王阳明传，突然想到我们没有&lt;code&gt;知行合一&lt;/code&gt;啊。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>重构已死</title>
      <link>http://lanlingzi.cn/post/technical/2016/0123_refactor_death/</link>
      <pubDate>Sat, 23 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0123_refactor_death/</guid>
      <description>&lt;p&gt;上周在食堂吃饭，遇到同事聊起最近的系统重构，她说这一批的新员工不如13年的一批，就一个看似简单的问题也是折腾很久，重构的周期越拉越长。我作为这次的重构的特性SE，可以说也是硬着头皮上。我是越来越反感重构，尤其是涉及到多个模块的重构。在新年的聚餐上，我说我给你挖了坑，你来填坑，让我感到非常惭愧的，即又不得做这些事。&lt;/p&gt;

&lt;p&gt;在现阶段项目交付变得越来越难，一方面我们面对众多的需求，做还是不做并不是你能轻易决定的；而另一方面我们又想从架构上解决可以快速满足需求。但本质的是这几个月内，人的技能与意识没有根本性的变化。在大家没有主人翁的精神下，说来说去也是为了需求在垒代码。即使你想从代码结构上重新设计，让系统更松的耦合性，更好的扩展性。受于项目进度冲击，以及代码实现者的被动，最终也会变得让你不想回头多看一眼。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Taipei-Torrent源码分析</title>
      <link>http://lanlingzi.cn/post/technical/2016/0117_torrent_go/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0117_torrent_go/</guid>
      <description>&lt;p&gt;提到P2P，总会少不了BitTorrent。BitTorrent是一种P2P协议。BitTorrent协议是由程序员Bram Cohen在2001年四月份设计的，最终版本在2008年确定。&lt;/p&gt;

&lt;h2 id=&#34;bittorrent协议简介&#34;&gt;BitTorrent协议简介&lt;/h2&gt;

&lt;p&gt;一个BitTorrent的文件在网络传输过程，由以下几个部分组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WEB服务器&lt;/li&gt;
&lt;li&gt;文件元信息(metainfo)&lt;/li&gt;
&lt;li&gt;BitTorrent Tracker&lt;/li&gt;
&lt;li&gt;原始资源发布者&lt;/li&gt;
&lt;li&gt;目的端用户浏览器&lt;/li&gt;
&lt;li&gt;目的端用户下载者&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>软件分发加速</title>
      <link>http://lanlingzi.cn/post/technical/2016/0116_speed_sw_distribute/</link>
      <pubDate>Sat, 16 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0116_speed_sw_distribute/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://image.xinmin.cn/2011/04/06/20110406151112514943.jpg&#34; alt=&#34;balance&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;在云环境下，服务器（物理机）或虚拟机越来越多，存在同一个应用软件需要大规模地部署场景。传统的方式下是搭建一个软件仓库，由物理机或虚拟机节点直接从软件仓库下载。如果采用sftp或http协议，则只能做到从一个中心软件仓库分发软件包给其它的节点，若给上百台的节点同时分发同一软件包，则存在受带宽、负载限制等因素，导致分发的速度就会比较慢。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何看待Docker</title>
      <link>http://lanlingzi.cn/post/technical/2016/0107_docker/</link>
      <pubDate>Thu, 07 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0107_docker/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/docker/docker_ecosystem.jpg&#34; alt=&#34;docker ecosystem&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从国内来看，从14年的发迹，到15年的红火。基于Docker的国内创业公司不停的涌现，Docker的概念不断地炒作。软件界似乎人人在谈论Dcoker，给我的感觉就像中国大妈跳广场舞一样，歌声大，动作乱，到底有没有用，难说。毕竟Docker只是一项技术，技术是否能成功应用，给你的产品带来价值才是最重要的。下面是个人一些对Docke的看法与见解，可能有不对之处，望交流赐教：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>7秒时光</title>
      <link>http://lanlingzi.cn/post/stories/2016/0103_7s_time/</link>
      <pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2016/0103_7s_time/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/7stime/IMG_8337.jpg&#34; alt=&#34;image1&#34; /&gt;
&lt;img src=&#34;http://lanlingzi.cn/images/7stime/IMG_8235.jpg&#34; alt=&#34;image2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;三天的元旦时间很快就过去，前两天是窝在家搞我这个网站。今天怎么也得出去走走，于是老婆约上她的几位好友，说去莲塘边的罗湖5号绿道感受一下大自然。天公有点不作美，一直下着毛毛细雨，但是我们还是意识坚定，风雨无阻。当我们一行7人踏上路程，蓦然发现朦胧细雨下的水库与5号绿道，别有一番诗情画意，望着不远的仙湖与梧桐山，他们就像一幅幅山水水墨画，恨不得把她们都收入到相机中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>新年新目标</title>
      <link>http://lanlingzi.cn/post/stories/2016/0101_new_year/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2016/0101_new_year/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://img.51tietu.net/upload/www.51tietu.net/2015-1/201501030207146601.png&#34; alt=&#34;footprint&#34; /&gt;&lt;/p&gt;

&lt;p&gt;韶华易逝，往昔不再。时间已翻到2016年，在15年的12月份，忽然做了一个决定，注册了lanlingzi.cn这个域名，开始鼓励自己写写东西。原由是在15年的下半年，工作上做一个重大的调整，暮然发现自已写东西有时真让人费解。这个域名上已有的文章，是我之前在CSDN上一些记忆，以及自已电脑上留下的文档。虽然在公司也会写写技术博文，但那些更倾向于技术的细节与程序语言，对问题的思考与见解少了一些。&lt;/p&gt;

&lt;p&gt;在16年的计划目标是每个月一到两篇，争取多写些有思想，有见解的干货。经过这几天的梳理，才有了这个网站。发现写东西是一个比较费时费脑力的事儿，甚至比写起代码来还难。苦于自己的文思，文笔，写完之后，有时连自己都看不下去，一堆的错别字，语句不通顺。有时，脑子中是飞快地转，好似有千言万语，下笔时却不知从何写起。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>虚拟与现实</title>
      <link>http://lanlingzi.cn/post/stories/2015/1231_debian_ian_die/</link>
      <pubDate>Thu, 31 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2015/1231_debian_ian_die/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://img.article.pchome.net/00/37/34/79/pic_lib/s960x639/Operating_Systems_015s960x639.JPG&#34; alt=&#34;Debian&#34; /&gt;&lt;/p&gt;

&lt;p&gt;万万没想到，在即将迎来2016年时，微信，科技新闻中都在传&lt;a href=&#34;http://www.leiphone.com/news/201512/Rnum0JX3yn5sxU3l.html?t=1451547845009&#34;&gt;“Debian创始人Ian Murdock离奇死亡，曾发推表示要自杀”&lt;/a&gt;。作为一个对Debian系Linux的忠实爱好者，有种莫名的感伤，对大神的离去表示衷心的哀悼。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>参加ArchSummit北京站感受</title>
      <link>http://lanlingzi.cn/post/technical/2015/1227_bj_archsummit/</link>
      <pubDate>Sun, 27 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/1227_bj_archsummit/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://q.infoqstatic.com/ASSZ2015/LOGO/AS-LOGO358x146.png&#34; alt=&#34;ArchSummit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参加ArchSummit北京站已有一周时间，一直没有时间来梳理一下。整体来说，这次的北京之行，不是很满意，可能是这类会议听多的原因，感觉ArchSummit的质量是越来越差了，没有什么新鲜感，觉得不值那6K的价格。&lt;/p&gt;

&lt;h2 id=&#34;组织不足&#34;&gt;组织不足&lt;/h2&gt;

&lt;p&gt;12月份的北京已是非常的干冷，可能由于我在南方呆久了，一到北京是极其地不适应，在北京三天多的时间，嘴唇开裂，到现在还没有完全好干净。离开北京的那一天，正好又感受了一下北京正宗的霾，帝都的人们活得真不容易啊。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我为什么喜欢GoLang</title>
      <link>http://lanlingzi.cn/post/technical/2015/1113_why_love_go/</link>
      <pubDate>Fri, 13 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/1113_why_love_go/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://img3.imgtn.bdimg.com/it/u=3850601748,68654193&amp;amp;fm=21&amp;amp;gp=0.jpg&#34; alt=&#34;gopher&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从8月份到现在，一直在公司尝试用Go写点东西。虽然我们几乎是清一色的Java开发，但我还是愿意在同事之间推广Go，有时间还是学学Go吧。&lt;/p&gt;

&lt;h2 id=&#34;认识go&#34;&gt;认识Go&lt;/h2&gt;

&lt;p&gt;我大概是一个不太执着的语言控，什么语言喜欢玩玩，在大约在12年时，就开始自学Go，但仅仅是看看语法，写写Helloword之类的小程序而已。在13年底，我被抽去分析Cloud Foundry的架构与实现机制。当时的CF是V2版本，其中的GoRouter，HM9000已采用Go重写，另外消息总线NATS也有Go语言版本。而我又重点分析了NATS，HM，以及部分GoRouter的Go源码。发现居然Go能写出如此简练的代码。性能验证时，又发现Go版本的NATS比Ruby版本的强得不是一点点，我们在单板上测试出有50万+的QPS。14年做融合架构，又把我们原有的消息中间件RabbitMQ换成了NATS。当时的出发点主是能与CF通过NATS融合拉通，另外是看重它的高性能。而RabbitMQ是erlang写的，部门熟悉erlang人几乎没有，维护成本高。当然到现在来看，NATS太简单了，并不是个消息队列，很多的特性都没有。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mesos与K8S的区别</title>
      <link>http://lanlingzi.cn/post/technical/2015/1020_k8s_mesos/</link>
      <pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/1020_k8s_mesos/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://dn-sdkcnssl.qbox.me/editor/fWnRKkZgug2fvzeDNd8k.jpg&#34; alt=&#34;pets vs cattle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近经常有同事问道，mesos与k8s有什么不同？平时对k8s要研究多一些，对mesos仅限于一些网上的了解。前一段时间去参加阿里云栖大会，正好也有一场是由于Mosos及Mesosphere公司的人来现身说“法”，听了之后对mesos算了解更深一点吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>成都映象记</title>
      <link>http://lanlingzi.cn/post/stories/2015/0926_chengdu/</link>
      <pubDate>Sat, 26 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2015/0926_chengdu/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://t0.fansimg.com/uploads2012/01/userid65405time20120101160054.jpg&#34; alt=&#34;成都锦里&#34; /&gt;&lt;/p&gt;

&lt;p&gt;风味十足的四川话，风姿卓然的川妹子，麻辣干香的风味菜，是我是对成都的初步映象。有“天府之国”、“蜀中苏杭”美誉的成都蓉城，在小说与故事中都有耳闻，向往已久。在上高中时，就想报考虑成都的高校，无奈分数不够高，被调济到北方。这次作为招聘技术面试官出差来了一趟成都，了却了一桩十几年前的心愿。&lt;/p&gt;

&lt;p&gt;作为面试官，我们必须西装革履，多年的散慢习惯，反而不太适当。我们下榻的酒店，环境与生活还算不错，但是地理位置有点偏，即使晚上空闲下来，也难以感受到成都的气息。招聘其实是个苦差事，连续二天集中的面试时间，已让我有些疲倦。第三天中午面试完最后几个之后，下午忽然空闲下来。秘书说下午面试预约已结束，我们几个来自深圳的同事可以去成都逛逛。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>参加CNUTCon全球容器大会感受</title>
      <link>http://lanlingzi.cn/post/technical/2015/0902_bj_cnutcon/</link>
      <pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0902_bj_cnutcon/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/docker/cnut.png&#34; alt=&#34;cnutcon&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于最近一直在从事Docker相关的工作，所以有机会参与这次的&lt;a href=&#34;http://cnutcon.com/&#34;&gt;CNUTCon全球容器大会&lt;/a&gt;。名字比较“高格”，虽有少量的外国人分享，大部分还是中国的互联网企业在宣传，忽悠。除去这些，整体来说这次大会还是非常不错的，门票也不算太贵，目前看来应该还是值的。我司还是这次大会的钻石赞助商，也说明我们在容器这一块的发力程度。&lt;/p&gt;

&lt;h2 id=&#34;整体感受&#34;&gt;整体感受&lt;/h2&gt;

&lt;p&gt;Docker是这这两年成长最快的技术，受到资本市场的热捧。Docker技术以势不可挡地席卷全球。参考这次大会，整体感受是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker已不再是概念，已进入互联网企业的实际生产环境中&lt;/li&gt;
&lt;li&gt;Docker的创业公司多，有远见的想在这次的浪潮中分享红利&lt;/li&gt;
&lt;li&gt;大公司借Docker东风，亦想在云计算领域中拿下更多话语权&lt;/li&gt;
&lt;li&gt;容器技术处于战国群雄，完整的生态还比较混乱技术栈不成熟&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>配置与定制</title>
      <link>http://lanlingzi.cn/post/technical/2015/0813_cfg_vs_cus/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0813_cfg_vs_cus/</guid>
      <description>&lt;p&gt;作为一个软件人员，我们会经常遇到各种各样的需求，有时为了避免定制，通常的做法是提供更多的配置选项，以通过配置出满足不同的特定需求。&lt;/p&gt;

&lt;p&gt;原因是而当你开发定制代码来修改或扩展一个功能需求时，有可能会导致软件不能正常的工作，必须通过严格的测试与验证。在重大的版本升级情况下，定制是苛刻的和耗时的。甚至会面临无法修复的功能可能会被重构，从零开始。因此，一些做法是通过采越来越多地选择配置，来解决由于开发定制代码引入的问题与软件带来的成本。&lt;/p&gt;

&lt;p&gt;因此配置与定制之间的区别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置：使用现有的数据来配置系统以满足您的业务需求&lt;/li&gt;
&lt;li&gt;定制：将定制或使系统适应业务需求，涉及到定制开发流程。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>微服务与SOA</title>
      <link>http://lanlingzi.cn/post/technical/2015/0516_microservice_soa/</link>
      <pubDate>Sat, 16 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0516_microservice_soa/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://martinfowler.com/articles/microservices/images/sketch.png&#34; alt=&#34;microservices&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我司学习一个新的技术，往往是搞得轰轰烈烈，比如数字化转型，向互联网技术学习。其中一个非常重要的方向就是学习互联网的服务化体系架构。国内的阿里，京东，腾讯在服务化，确切地说是微服务应用取得非常大的成功。而国外的Netflix的微服务架构更是成为我们必定的样板教材。你做设计，谈方案，不说说微服务都不好意思。如果你不说这样，说明你思维落后陈旧了。任何一项技术都有一段疯狂期，虽这近一次在搞架构重构，领导遇到你，总是关心地问到：“服务化进展怎么样了”。甚至还得跟一些不太懂的领导解释什么是微服务。&lt;/p&gt;

&lt;p&gt;10年前差不到了SOA也像今天的微服务一样火爆。那微服务与SOA的关系或区别是什么？是不是SOA的旧洒换新瓶？软件界的大牛 Martinfowler的《&lt;a href=&#34;http://martinfowler.com/articles/microservices.html&#34;&gt;微服务&lt;/a&gt;》更是像一部微服务的圣经，无奈是E文，大家都有各自的理解。在我司更是大家对这个各抒己见，谁都可以说上几句服务化的原则是什么，微服务成了领导专家们口里的口头禅。如果我们的系统不是微服务化，都怀疑我们系统的先进性。想当初，大家也都谈SOA，也极力推广SOA。似乎到了今天，微服务与SOA两者是势不相容。SOA是传统的IT架构，而微服务是当今互联网架构，微服务似乎比SOA更“逼格”。甚至这样的争论成了不同兄弟的心头痛。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>架构重构</title>
      <link>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</guid>
      <description>&lt;p&gt;最近一直在做系统架构上重构工作，理论不能不学习啊，只有在思想上把自己武装起来，才能减少我们工作上的错误。之前参加过或亲自操刀过多次的代码局部或模块重构，但这一次架构重构是范围波及最广，收获颇多。&lt;/p&gt;

&lt;h2 id=&#34;什么是重构&#34;&gt;什么是重构&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;重构是指在不修改代码外在行为的前提下，对代码做出的修改，以改进程序的内部结构，提高其可理解性，降低其修改成本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是来自马大神的《重构》一书对重构释义。重构可以改进软件设计；使软件更容易理解；使软件更容易维护；帮助找到软件Bugs；帮助提高编程效率。重构按对系统修改的粒度层次可以分为如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部代码重构，操作与实施比较容易，《重构》一书中介绍了大量经典的方法。&lt;/li&gt;
&lt;li&gt;模块级代码重构，可能涉及到模块之间的接口重构，操作与实施难度相对适中。&lt;/li&gt;
&lt;li&gt;架构重构，是对整个系统架构层次的重构，牵系相当的广，操作与实施难度比较高。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>OSGi的缘起缘灭</title>
      <link>http://lanlingzi.cn/post/technical/2015/0422_remove_osgi/</link>
      <pubDate>Wed, 22 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0422_remove_osgi/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://www.osgi.org/wp-content/uploads/bigpuzzle.jpg&#34; alt=&#34;osgi&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是osgi&#34;&gt;什么是OSGi&lt;/h2&gt;

&lt;p&gt;维基百科：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OSGi（Open Service Gateway Initiative）有双重含义。一方面它指OSGi Alliance组织；另一方面指该组织制定的一个基于Java语言的服务（业务）规范——OSGi服务平台（Service Platform）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们所说的OGSi，通常讲的是Java语言实现的OSGi，但也是有其它语言实现过OSGi，由于没有Killer应用，几乎是无人知晓。&lt;/p&gt;

&lt;p&gt;2003年Eclipse选择OSGi作为其插件的底层运行时架构。Equinox project对该理念进行了实验，2004年6月在Eclipse3 R3中发布。Eclipse的成功让人认识到OSGi的优秀与魅力，也把OSGi带到众多的程序员面前。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件开发中缺陷管理</title>
      <link>http://lanlingzi.cn/post/thoughts/2014/0901_soft_dev_dt_trace/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2014/0901_soft_dev_dt_trace/</guid>
      <description>&lt;p&gt;在我司，我发现大家很擅长把一个东西到极致，但极致可能是过犹不及了，例如测试并不是发现越来越多的Bug就越好，如果把很多的时间消耗到一些不重要的点，反而不可取，软件只要你去测试，怎能发现一些Bug，如要面对这些就非常纠结。作一名开发，说这话肯定会被一批的测试人员拍砖死了。在此表达一下不同的观点，不一定正确，请轻拍。&lt;/p&gt;

&lt;p&gt;在我司的各种度量工具很牛X，缺陷跟踪分析每个迭代阶段就会做，形成一些报告。对于软件质量来说，统计所有过去的Bugs是没有多大用的，相对来说，一些更实际的工作可能更重要，在Douglas Hubbard的《How to Measure Anything: Finding the Value of Intangibles in Business》(如何衡量任何事：寻找商业无形资产的价值)中，把这种现象解释成衡量倒置(Measurement Inversion)：衡量一个东西的经济价值与它通常所受到的关注度多少成反比。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件开发与中医理论</title>
      <link>http://lanlingzi.cn/post/thoughts/2014/0804_soft_dev_tcm_theory/</link>
      <pubDate>Mon, 04 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2014/0804_soft_dev_tcm_theory/</guid>
      <description>&lt;p&gt;最近一段时间，看了些的版本迭代开发数据。有CI中QDI，FindBugs，重复率，复杂圈度；也有迭代的Story实现率，IR分解率，DI值;也有测试用例，覆盖率，执行时长，入门用例比等。反正各种度量数据多得是，从各个方面来反馈项目的质量。俗话说：有人的地方就有江湖。有江湖的地方就有纷争。有度量数据就有晒马排名，有排名的地方就有政治任务。我们的流程辅助度量工具多了，但这些真能带动我们的质量上去了吗？&lt;/p&gt;

&lt;p&gt;小儿已一岁多，现在回顾他做的一些体检。前三个月每月一次体检，一岁之前每3个月一次，一岁之后是每6个月一次。体检的项目有称体重、量身高、量头围、量胸围、验视力、测听力、检查动作发育、口腔检查、评价智能发育、验血、骨骼检查、心肺与心率检查、大便和血红蛋白。体检医生一上来就是开各个体检单，采用是西医的方式，看指标数据，再评测，体检应该是医院最好的生财路之一。个人也明白，正如我妈说的，我小时候哪有什么体检，也不是好好的吗？现在带小孩去体检，也是图个安心，提早预防。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>做一名好的开发人员</title>
      <link>http://lanlingzi.cn/post/thoughts/2014/0729_better_developer/</link>
      <pubDate>Tue, 29 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2014/0729_better_developer/</guid>
      <description>&lt;p&gt;我在上一次的新员工交流会议上，问新员工对全栈工程师了解不，我们的目标是成为一名全栈工作师，而不是做一名只会写代码的码工。最近遇到一些不开心的事，可能是在华为呆久了，发现到底都要会学扯皮。而我性情不太喜欢做一些自认为这些是无意义的事情。虽然有前辈告诉我，扯皮可能的效果会让你少加班几个月。说着说着，有点偏了，扯皮其实是沟通成本。项目越大，沟通成本越高。带个项目的人都会意识到，项目中的人力是1+1&amp;lt;2的，人越多效率越低。因为沟通是需要成本的，不同技术的人各说各话，前端和后端是一定会掐架的。每个人都会为自己的利益而战，毫不为已的人是不存在的。&lt;/p&gt;

&lt;p&gt;减少沟通成本，我们需要全栈工程师，因为各种技术都懂，胸有成竹，自己就全做了。即使是在团队协作中，与不同技术人员的沟通也会容易得多。懂你的，你懂的，相互理解，也就少了很多的时间在扯。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git SSH设置</title>
      <link>http://lanlingzi.cn/post/notes/2014/0322_github/</link>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2014/0322_github/</guid>
      <description>Git HTTPS 和 SSH 的区别： 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则</description>
    </item>
    
    <item>
      <title>优秀程序员</title>
      <link>http://lanlingzi.cn/post/thoughts/2013/1113_good_programmer/</link>
      <pubDate>Wed, 13 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2013/1113_good_programmer/</guid>
      <description>&lt;p&gt;关于什么是一名合格的程序员，优秀的程序员，这些讨论从来没有停止过，标准各不相同。有人说优秀程序员追求简洁的代码，优秀的框架结构，新的技术技能。我们不是在讨论什么是业界大牛，我心中的一名优秀程序具备如下几个素质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简洁高效&lt;/p&gt;

&lt;p&gt;优秀的程序员会使用整洁，易于理解的方式解决实际的问题，任何不必要的复杂代码均不会出现，简单比复杂更具有价值。能通过简洁的方式把复杂的问题解决掉。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>HW八年总结</title>
      <link>http://lanlingzi.cn/post/thoughts/2013/0909_hw_8years/</link>
      <pubDate>Mon, 09 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2013/0909_hw_8years/</guid>
      <description>&lt;p&gt;白驹过隙，进入公司已是八年，一路学习一路收获。往后回首，一些经历回想起来还历历在目：经历过一线比拼的激情，经历过产品上线的喜悦，经历过多个项目的变换，经历过持续熬夜的艰辛；写过不少的代码，带过一些徒弟，负责过团队开发，一直在公司从事基层的研发工作。一路走下来，也得到部门领导，公司同事的帮助、指导与鼓励，能让我一直坚持下去，过程中我也得到一些很高的认可，感触多，收获多。在此我先感谢大家！&lt;/p&gt;

&lt;h2 id=&#34;团队成功才能成就个人&#34;&gt;团队成功才能成就个人&lt;/h2&gt;

&lt;p&gt;还记得进入公司做的第一个项目，就是上海电信的XXX规范比拼项目，在上海一呆就是3个月之久。之后从09年开始到现在，我应该遇到一个不错的机遇，时逢部门的产品在欧洲开花结果，并且我非常有幸地参加了其中的多个项目，TLF比拼、VDF比拼、SFR比拼、O2的交付，DT比拼，有去一线出差现场操作，也有在家持续熬夜支撑。后又参与平台非常重要的新项目C3的构建，见证它从无到有，到多个局点的交付，目前C3在VDF交付。所以说是 &lt;strong&gt;只有团队的成功，才能有个人的成就&lt;/strong&gt; 。我作为一个普普通通的软件工程师，有机会参加了这么多的高端比拼与交付，也可能实属我人生中为数不多，以后可能值得会拿出来说一下的事儿。当然参与这些项目对我自身也是一项非常大的挑战，尤其是在比拼项目中亦时候不知熬了多少个夜晚，甚至彻夜难眠，也不知当面对客户苛刻的验证时的紧张感，心跳加速多少次。但始终相信我是在做一件有意义的事情这就是对的，虽然过程肯是辛苦的，结果可能不理想的。有时甚至还害怕而抵触过，抱怨过。但只要一旦接受了也就始终没有放弃过，&lt;strong&gt;把分给我的工作尽自己最大的努力做好做实，做到问心无愧&lt;/strong&gt; 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java线程使用建议</title>
      <link>http://lanlingzi.cn/post/technical/2013/0424_java_thread_suggest/</link>
      <pubDate>Wed, 24 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2013/0424_java_thread_suggest/</guid>
      <description>&lt;p&gt;最近Review团队内一些的代码，发现不少地方在使用线程池，但使用比较乱，针对问题建议如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;线程不能调用Thread.stop来停止它，我见过有新员工就这么干过哦，而是需要设置一个标识位，在run方法中判断此标识位退出循环。用interrupt也是可以考虑的，但线程的run方法中要捕获InterruptException。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有线程需要设置Name，主要是方便线程dump出来之后定位问题。这可是编程军规，我们很多的兄弟没有遵守。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[WebApp沙箱]SecurityManager运用</title>
      <link>http://lanlingzi.cn/post/technical/2011/0212_java_sandbox_sm/</link>
      <pubDate>Sat, 12 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2011/0212_java_sandbox_sm/</guid>
      <description>&lt;p&gt;在JRE类白名单能控制类的使用权限（&lt;a href=&#34;http://lanlingzi.cn/post/technical/0311_java_sandbox_cl&#34;&gt;请点击&lt;/a&gt;），但控制不了一些资源的访问权限。如默认情况下可访问机器下的任意资源，如读取、删除一些文件，网络操作，创建进程与线程等。必须对Web容器下的WebApp进行资源权限访问控制。&lt;/p&gt;

&lt;h2 id=&#34;security-manager&#34;&gt;Security Manager&lt;/h2&gt;

&lt;p&gt;Java从JDK 1.0开始就实现一套安全架构，主要用于Applet。在这种体系下Java Code的执行环境被严格划分为两部分，本地代码可以访问计算机的所有资源，而远端代码（Remote Code，主要是Applet）只能支行在严格限制的沙箱里面。安全管理器（&lt;code&gt;SecurityManager&lt;/code&gt;）作为一个子系统来决定哪些资源允许沙箱中程序访问。这是一种运行期的安全检查。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[WebApp沙箱]JRE类白名单运用</title>
      <link>http://lanlingzi.cn/post/technical/2011/0311_java_sandbox_cl/</link>
      <pubDate>Fri, 11 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2011/0311_java_sandbox_cl/</guid>
      <description>&lt;h2 id=&#34;classloader&#34;&gt;ClassLoader&lt;/h2&gt;

&lt;p&gt;JVM类加载器层次结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;   Bootstrap ClassLoader
            |
   Extension ClassLoader
            |
   System ClassLoader&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JVM一启动，会先做一些初始化的动作。一旦初始化动作完成之后，就会产生第一个类加载器，即所谓的Bootstrap Loader, Bootstrap Loader是由C++写成，这个BootstrapLoader所做的初始化中，除了做一些基本的初始化动作之外，最重要的就是加载定义在sun.misc命名空间下的Launcher.java之中的ExtClassLoader(因为是innerclass，所以编译之后会变成Launcher$ExtCjassLoader.class)，并设定其Parent为null,代表其父加载器为BootstrapLoader。然后再加载定义于sun.misc命名空间下的Launcher.java之中的AppClassLoader(因为是InnerClass，所以编译之后会变成Launcher$AppClassLoader.class)，并设定其Parent为之前产生的ExtClassLoader实例。AppClassLoader这一层我们也称之为SystemLoader。AppClassLoader会加载CLASSPATH目录下定义的Class。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>远离罪恶</title>
      <link>http://lanlingzi.cn/post/stories/2011/0122_believe_god/</link>
      <pubDate>Sat, 22 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2011/0122_believe_god/</guid>
      <description>&lt;p&gt;今天在回家的车上，遇到一个上帝的信徒，在宣传上帝的故事，对着一个高中生大讲特讲信上帝不是一种迷信。举了很多的例子，比如人们熟知的爱因斯坦，牛顿等是上帝的忠实信徒，一边搞学问一边翻圣经，学问做不去了，就去问圣经。也讲宇宙是什么，是上帝创造了宇宙万物，人类就是大海中一粒沙一样存在整个宇宙之中，人类是渺小的。无论人类科技多么的发展，也不能在其它星球上创造生物。最后在快下车的时候，给每人发一张卡片，劝说人们多去教堂感受一下。身体只是一个灵魂的载体，每个灵魂需要远离罪恶，前往永远与罪恶无关的福乐美地。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>德国出差记</title>
      <link>http://lanlingzi.cn/post/stories/2010/1020_german_travel/</link>
      <pubDate>Wed, 20 Oct 2010 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2010/1020_german_travel/</guid>
      <description>&lt;p&gt;到达德国的Frankfurt法兰克福大约是19号早晨的６点半左右。这边的天还没有亮，取得托运行李，再过完签证检查之后已是７点左右，天还是没有亮。这次还好，去年过境德国，被安检人员问了一堆的问题。这次可能我事先跟海关检查人员打了声招呼“Morning”，他居然什么都没有问，直接盖上大章就说“Pass”。出了Airport，外面非常的冷清，11月的德国已经开始很冷，有点冬的味道。&lt;/p&gt;

&lt;p&gt;我要去的目的地是一个叫Darmstadt达姆斯塔特的小城。在Airport的外面bus stations逛了一圈，终天在Terminal 2 E8找到Darmstadt的air line。等了大约２分钟的时光，Bus准时到来，我向司机打了声招呼，示意让我上车。在车上他说了一堆的德语，可惜我一句也没有听明白，我只能用生硬的英语说“I want to go to Darmstadt, how much is the ticket?”或许大家都能听明白Darmstadt。于是他在电子售票机上打了一张票给我，电子屏上显示7.3欧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>印度同事记</title>
      <link>http://lanlingzi.cn/post/stories/2010/0716_indian_counterparts/</link>
      <pubDate>Fri, 16 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2010/0716_indian_counterparts/</guid>
      <description>&lt;p&gt;项目组由四地员工组成：深圳，南京，印度，土耳其。印度研究所设在班加罗尔（Bangalore），由于这次项目的重要性，把一堆的印度同事也拉到了深圳集中办公，也把部分的土耳其同事拉到了深圳。&lt;/p&gt;

&lt;p&gt;今天有两个印度同事说要回家结婚了，准备回印度，于是他们昨天发了一封mail说要我&lt;code&gt;join us for dinner&lt;/code&gt;。盛情难却，于是我说&lt;code&gt;I&#39;m glad to go&lt;/code&gt;，我就参加了他们的一次聚会。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>团队文化</title>
      <link>http://lanlingzi.cn/post/notes/2010/0111_team_culture/</link>
      <pubDate>Mon, 11 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2010/0111_team_culture/</guid>
      <description>&lt;p&gt;今天晚上在部门的公告牌上看到一个另部门的项目做的总结，觉得后面几句话不错：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;树立团队荣誉感：&lt;/p&gt;

&lt;p&gt;如何树立团队荣誉感，没有什么好方法，我的理解就是带领团队不断地打胜仗，克服一个个困难，另外就是获得应该有的荣誉，这样你的团队才能有荣誉感。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;角色认知，系统化思考：&lt;/p&gt;

&lt;p&gt;你是代表部门在做这项工作，需要也可以站得更高角度来系统化，有计划地操作这项工作，你也可以行使你应有的权力。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>2010</title>
      <link>http://lanlingzi.cn/post/stories/2010/0106_summary/</link>
      <pubDate>Wed, 06 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2010/0106_summary/</guid>
      <description>&lt;p&gt;日子就这一样日复一日地消逝着，&lt;br /&gt;
在不经意间，&lt;br /&gt;
时间滑到2010。&lt;br /&gt;
无意与时间赛跑，&lt;br /&gt;
在时间面前，&lt;br /&gt;
我们永远都是一个输者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回首2009&lt;/strong&gt;，&lt;br /&gt;
一个充满辛苦的一年，&lt;br /&gt;
一个压力倍增的一年。&lt;br /&gt;
去了一趟欧洲，&lt;br /&gt;
去了一趟南京。&lt;br /&gt;
工作走到十字路口，&lt;br /&gt;
有更多的人生盲点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>秩序</title>
      <link>http://lanlingzi.cn/post/stories/2009/1106_rule/</link>
      <pubDate>Fri, 06 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2009/1106_rule/</guid>
      <description>&lt;p&gt;昨天下班回来，当过马路时，我一个人在等红绿灯，忽然有一个人在喊我：”走啊，你们这群年轻还没有我们胆子大啊，现在都没有车“，我回头一看，是一个大约40~50岁的人，应该是我们公司供应商的员工。而我，已经习惯了过马路时等红绿灯，在我们公司附近，大家都这样做，即使没有车也会静静地在等着灯亮，这可能是榜样的力量吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>青青世界</title>
      <link>http://lanlingzi.cn/post/stories/2009/1004_qingqing/</link>
      <pubDate>Sun, 04 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2009/1004_qingqing/</guid>
      <description>&lt;p&gt;少年时，一首青青世界的歌曲在春晚上唱红南北。歌里描绘的是一个梦幻世界，是我一直梦想的世界，一副有山有水的清净世界，歌词的作者天才乔羽现在是否还安好？听我们的老大们讲，乔老创造这首歌时，本来是我们公司请他来为公司写企业主题歌，就他住进了当时公司的培训与生活基地青青世界（那时青青世界刚开没有多久，资金运营上有困难，所以把酒店都包给公司）。精明的青青世界台湾老板自然是不会放过送上门来的文坛泰斗，于是就有了后来的青青世界这着歌，也让青青世界这个旅游景点火一把。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>家有老人</title>
      <link>http://lanlingzi.cn/post/stories/2009/0906_grandpa/</link>
      <pubDate>Sun, 06 Sep 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/stories/2009/0906_grandpa/</guid>
      <description>&lt;p&gt;昨天去一了趟广州小叔那，我去看爷爷。岁月催人老，一晃我爷爷马上80岁了。我差不多每一年才与他见面一次，主要是回家过年时。每次见到他，都感觉他越来越苍老，不过今年他的身体还不错，希望他能健康百岁。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>读史小记</title>
      <link>http://lanlingzi.cn/post/notes/2009/0822_history_think/</link>
      <pubDate>Sat, 22 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2009/0822_history_think/</guid>
      <description>&lt;h2 id=&#34;战乱多&#34;&gt;战乱多&lt;/h2&gt;

&lt;p&gt;自从买了个诺基亚的大E之后，在手机上看书的时间越来越多了，最近一连看了好几本历史相关的书籍。原来中国的历史并非课本上写的那么简单。两千年来，中国历史能值得我们骄傲的并不多，对于普通百姓来说，一直是充满着无知与无奈。对于官员来说，一直是充满着虚伪与争斗，对于帝王来说， 一直是充满着荒唐与淫乱。在历史长河，没有几个太平盛世，没有几个有作为的帝王，没有几个能臣干将。整个中原民族也是不断地受到外族侵略，也不断的融合其它的民族。李世民是鲜卑族，成吉思汗是蒙古族，康熙是满族。强大的政权往往是由外族创建，而后才慢慢融合到汉族中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>性能设计</title>
      <link>http://lanlingzi.cn/post/technical/csdn/perform_design/</link>
      <pubDate>Wed, 22 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/perform_design/</guid>
      <description>&lt;p&gt;无论Java还是C++都有不少的性能优化工具。公司曾有人把一个系统从几十TPS优化到上千TPS，真是让人佩服到五体投地。但是由于架构的原因导致性 能问题，那就不好下手优化了。&lt;/p&gt;

&lt;p&gt;在软件项目设计前期，不可不能考虑性能设计。要确定好的性能要求，必须识别项目约束、确定软件将执行的服务并指定软件期望的 负载。但也不要过于注重性能设计。太注重往往会陷入设计的误区。有时甚至为了性能而牺牲功能，那是大错特错了。&lt;/p&gt;

&lt;p&gt;项目交付时首先是功能是否满足，其它才是性 能。换句话说软件首先要能工作，其次才是否能高效率的工作。性能设计必须依托测试结果。不要我以为这样做法性能会好。而现在很多的所谓的系统分析设计师却 喜欢我以为，爱拿以前的经验做依托，更喜欢拿其它项目成功的性能设计套用，岂知此系统非彼系统。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之名字空间namespace</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_namespace_usage/</link>
      <pubDate>Mon, 13 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_namespace_usage/</guid>
      <description>&lt;p&gt;C开发人员会经常使用&lt;code&gt;#define&lt;/code&gt;即宏来声明常量，但宏却是全局的，对大的工程来说是很难维护，经常是导致名字冲突。还好，C++给我们带来了&lt;code&gt;namespace&lt;/code&gt;名字空间。它的使用如下，名字空间可以把一组逻辑分组，同时名字空间也是一种作用域。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;namespace outspname  
{   
   const int CVAR1 = 1;  
   const char* const CVAR2 = &amp;#34;33333&amp;#34;;  
   void test();  

   namespace inspname  
   {  
      enum { A, B, C};  
      class Klass  
      {  
      };  
   }  
}&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>面向对象的设计原则</title>
      <link>http://lanlingzi.cn/post/technical/csdn/oo_design_principle/</link>
      <pubDate>Fri, 03 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/oo_design_principle/</guid>
      <description>&lt;p&gt;如何同时提高一个软件系统的可维护性和可复用性是面向对象的设计要解决的核心问题。&lt;/p&gt;

&lt;p&gt;导致一个软件设计的可维护性较低，也就是说会随着性能要求的变化而“腐烂”的真正原因有四个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;过于僵硬&lt;/li&gt;
&lt;li&gt;过于脆弱&lt;/li&gt;
&lt;li&gt;复用率低&lt;/li&gt;
&lt;li&gt;黏度过高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个好的系统设计应该有如下的性质，这三条性质就是一个系统设计应当达到的目标。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可扩展性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;可插入性&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] STL容器中erase方法的不同陷阱</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_erase_fault/</link>
      <pubDate>Wed, 01 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_erase_fault/</guid>
      <description>&lt;p&gt;&lt;code&gt;STL&lt;/code&gt;中的容器都有&lt;code&gt;erase&lt;/code&gt;方法，容器的存储分为顺序存储(如&lt;code&gt;vector&lt;/code&gt;)与链式存储(如&lt;code&gt;list,map&lt;/code&gt;)。先以&lt;code&gt;map&lt;/code&gt;为例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;typedef std::map&amp;lt;std::string, std::string&amp;gt; TStrMap;  
typedef TStrMap::iterator TStrMapIter;  
TStrMap strmap;  
TStrMapIter iter = strmap.find(&amp;#34;somekey&amp;#34;);  
strmap.erase(iter);&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样使用&lt;code&gt;erase&lt;/code&gt;方法没有任何问题，删除一个单结节之后，&lt;code&gt;stl&lt;/code&gt;中的&lt;code&gt;iterator&lt;/code&gt;都是与其中的数据元素关联的，关联的元素删除之后，&lt;code&gt;ite&lt;/code&gt;r已就失效，&lt;code&gt;iter&lt;/code&gt;理解为指向元素的指针，那删除之后可以简单理解为已是一个野指针。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;的仿函数与动态语言的闭包</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_closure_pkg/</link>
      <pubDate>Mon, 29 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_closure_pkg/</guid>
      <description>&lt;p&gt;什么是闭包，我们先来用&lt;code&gt;ruby&lt;/code&gt;看个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;sum = 0  
10.times{|n| sum += n}   
print sum&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;{}&lt;/code&gt;就是闭包的内容，代码看起来是不是很清爽与简单。&lt;/p&gt;

&lt;p&gt;我们还来看看&lt;code&gt;Python&lt;/code&gt;写的闭包：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;def addx(x):      
    return lambda y: x + y  
add8 = addx(8)  
print add8(100)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用Python写就没有那么好看。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之栈变量的析构应用</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_stack_usage/</link>
      <pubDate>Thu, 25 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_stack_usage/</guid>
      <description>&lt;p&gt;栈变量有一个好处，就是它退栈时会自动析构，并且在栈上对象生成比在堆上分配效率高很多。但每个线程的栈空间是有限的(创建线程时可以设置)，所以一般的临时小对象都会在栈上分配。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之operator操作符</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_operator/</link>
      <pubDate>Wed, 24 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_operator/</guid>
      <description>&lt;p&gt;这篇博文是以前很久写的，贴在我的早期一个blog中，今天google一下，发现还真有不少人转载，可惜并不注明出处。那时觉得&lt;code&gt;operator&lt;/code&gt;比较好玩。C++有时它的确是个耐玩的东东。&lt;code&gt;operator&lt;/code&gt;它有两种用法，一种是&lt;code&gt;operator overloading&lt;/code&gt;（操作符重载），一种是&lt;code&gt;operator casting&lt;/code&gt;（操作隐式转换）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]自己实现的queue</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_queue/</link>
      <pubDate>Sat, 20 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_queue/</guid>
      <description>&lt;p&gt;周末在家，自己用C++练一下手，用顺序存储与链表存储实现了队列queue。queue是一种先进先出的结构，有很多的应用，比如消息队列。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之断言Assert</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_static_assert/</link>
      <pubDate>Sun, 14 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_static_assert/</guid>
      <description>&lt;p&gt;断言的应该是一种编程的常见技巧。我所应用的断言有两种，一种是动态断言，即大家所熟知的C标准库的assert()宏，一种是C++中的静态断言，即在编译期间检查。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之宏Macro应用</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_macro_rule/</link>
      <pubDate>Fri, 12 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_macro_rule/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;宏不要用来定义常量，因为宏变量是没有类型安全，也没有名字空间约束，会造成名字的污染。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏的展开是一行，所以宏中的注释不能使用&lt;code&gt;//&lt;/code&gt;，只能使用&lt;code&gt;/* */&lt;/code&gt;。宏的代码也不能gdb跟踪，宏中代码逻辑要尽量简单。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏的参数一般情况下使用时要用()括起来，如:
&lt;code&gt;#define MAX(a, b) a /2 &amp;gt; b ? a /2  : b&lt;/code&gt;
MAX(3,4)使用没有问题，但MAX(3+4, 4)却有问题，因为宏的参数仅为符号替换。
应用定义为&lt;code&gt;#define MAX(a, b)  (a) / 2 &amp;gt;  (b) ?  (a) /2 : (b)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]自己实现的stack</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_stack/</link>
      <pubDate>Thu, 11 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_stack/</guid>
      <description>&lt;p&gt;还是前一段时间需要任职资格考试，自己练习一下栈stack的简易实现，今天把它贴出来，暴露的接口与STL类似，没有实现iterator迭代器。实现有两种方式， 基于顺序存储与链式存储。栈的特点是“后进先出”，在数学表达式运算，编译语法分析中，程序函数调用时最为常见。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用C&#43;&#43;模板来展示new与delete操作符原理</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_new_delete/</link>
      <pubDate>Mon, 08 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_new_delete/</guid>
      <description>&lt;p&gt;C++中的new与delete可以认为是C中的malloc与free的升级版本。new包含两部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一部分是与malloc功能相同，是从堆上面申请内存块&lt;/li&gt;
&lt;li&gt;第二部是调用类的构造方法来初始化刚申请的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;delete是new的逆过程，先调用类的析构方法来反初始化，再把刚申请的内存还给堆。&lt;/p&gt;

&lt;p&gt;new []与delete []是针对数组操作符，要注意是通过new []分配的对象，不能用delete来释放对象，否则会有内存泄漏。当然通过new分配的对象，不能用delete[]来释放对象。后面我会通过代码来说明为什么。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]常见的几个排序算法</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_aglos/</link>
      <pubDate>Sun, 07 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_aglos/</guid>
      <description>&lt;p&gt;前一段时间需要任职资格考试，于是又拿起丢了几年的数据结构书看了看，温习了一下常见的几个排序算法。今天特把我写的学习代码贴了出来。排序的算法常见有插入排序，选择排序与交换排序，较复杂一点还有归并排序与基数排序，概念性的东西我就不多说了，大家可以找一本严老师数据结构书看看。读大学时不觉得怎么样，现在再来看看，又结合这几年的编程经验，通过C++风格函数子造了一遍轮子。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于蘭陵N散記</title>
      <link>http://lanlingzi.cn/about/</link>
      <pubDate>Mon, 01 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/about/</guid>
      <description>关于我 我的网名叫兰陵昕云，也叫兰陵子。兰陵(蘭陵)来源于我的姓氏蕭，蕭姓起源于山东兰陵，所以也称为兰陵氏。但某机关因简化字的原因登记身份证蕭</description>
    </item>
    
  </channel>
</rss>